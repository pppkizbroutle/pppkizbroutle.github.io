<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-13 Tue 14:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Laboratorio</title>
<meta name="author" content="Erik Rangel Limón" />
<meta name="generator" content="Org Mode" />
<style type="text/css">/* Base */html,body {    background-color: #222;    min-height: 100%;    line-height: 1.5;}body {    color: #fafafa;    font-family: "Courier New";}::selection {    background-color:  #2ecc40;    color: white;}/* Responsive content positioning */@media only screen and (min-width: 1020px) /* Large screens */{    body{        padding: 10vh 25vw;    }}@media only screen and (max-width: 1020px) and (min-width: 750px) /* Small screens */{    body{        padding: 5vh 10vw;    }}@media only screen and (max-width: 750px) /* Small screens */{    body{        padding: 2vh 5vw;    }}/* Headers */h1{font-size: 2.5rem;}h2{font-size: 1.7rem;}h1 > .subtitle, h3, h4, h5, h6{font-size: 1.3rem;}.title{    margin-bottom: 2.5rem;}/* Padding & Margin */* {margin: 0; padding: 0;}pre, blockquote, ul, ol, p, table{    margin: 1rem 0;}h1, h2{margin-top: 2rem; line-height: 2rem;}h3, h4, h5, h6{margin-top: 1rem;}/* Links  */a, a:visited {    color: #01ff70;    text-decoration: underline;}a:hover, a:focus, a:active {    color: #2ecc40;}/* Code */pre {    font-family: "Courier New";    padding: .5rem;    background-color: #333;    padding: 0.5rem;    border-radius: 0.2rem;    font-size: 0.9rem;    color: #EEE;    overflow-x: auto;}.org-keyword{    color: #01ff70;}.org-rainbow-delimiters-depth-1{    color: #2ecc40;}.org-rainbow-delimiters-depth-2{    color: #01ff70;}/* Blockquotes */blockquote {    border-left: 3px solid #01ff70;    padding-left: 1rem;}li{    list-style-position: inside;}/* Tags */.tag{    margin-top: 0.5rem;    display: block;    color: white;    font-size: var(--font-size-xsmall);}.tag > span{		font-weight: 400;    font-size: 0.8rem;    background-color: #444;    text-transform: uppercase;    border-radius: 2px;    width: fit-content;    height: auto;    padding: 1px 5px;}/* Keywords */.todo{    color: #2ecc40;}.done{    color: #444;}/* Overflows */.outline-text-2, .outline-text-3, .outline-text-4{	  max-width: 100%;	  overflow-x: auto;}/* Table */tr:nth-child(even) {    background-color: #333;}th, td{    padding: 0.5rem;    text-align: center;}.underline{    text-decoration: underline;}img{    max-width: 100%;    height: auto;}</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Laboratorio</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgac8343f">Haskell</a>
<ul>
<li><a href="#org9ce3259">Instalación</a>
<ul>
<li><a href="#org7927872">Requerimientos</a></li>
<li><a href="#orge4074e2">GHCup</a></li>
<li><a href="#orgee49b98">Administrador de paquetes</a></li>
</ul>
</li>
<li><a href="#orga9ff121">Introducción</a>
<ul>
<li><a href="#orgfebe639">Variables y tipos primitivos</a></li>
<li><a href="#org74c55c7">Funciones</a></li>
<li><a href="#org07875e7">Operadores</a></li>
<li><a href="#org0b34376">Precedencia</a></li>
<li><a href="#org5ff19bf">Funciones anónimas</a></li>
</ul>
</li>
<li><a href="#orgf09cfa9">Listas, definiciones de tipos de dato y coincidencia de patrones</a>
<ul>
<li><a href="#orgd015a4f">Condicionales</a></li>
<li><a href="#org8ab349c">Coincidencia de patrones</a></li>
<li><a href="#orgb1443e3">Funciones de orden superior</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge3eb640">Lógica proposicional en Haskell</a></li>
<li><a href="#org8b3c920">Prolog</a>
<ul>
<li><a href="#orge4d5615">Predicados y constantes</a></li>
<li><a href="#org849a722">Consultas</a></li>
<li><a href="#org5660c27">Condiciones y Variables</a></li>
<li><a href="#orgd95c9c6">Backtracking</a></li>
<li><a href="#orgf716277">Números y Operadores</a>
<ul>
<li><a href="#orgbc3920e">Negación como falla</a></li>
<li><a href="#org4e5da61">Unificación</a></li>
</ul>
</li>
<li><a href="#org559a450">Ejemplos</a></li>
<li><a href="#org5f183d2">Listas y comodines</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgac8343f" class="outline-2">
<h2 id="orgac8343f">Haskell</h2>
<div class="outline-text-2" id="text-orgac8343f">
<p>
Es el lenguaje de programación que utilizaremos para realizar
la mayor parte de las prácticas de laboratorio.
</p>

<p>
Se propone éste lenguaje pues cuenta con transparencia referencial,
lo que garantiza que se pueda reemplazar una expresión con otra de
igual valor sin cambiar el significado de éste. Como consecuencia,
una función siempre producirá el mismo resultado para una entrada
dada, por lo que es posible construir, razonar y manipular programas
funcionales como si se tratasen de una expresión matemática.
</p>
</div>

<div id="outline-container-org9ce3259" class="outline-3">
<h3 id="org9ce3259">Instalación</h3>
<div class="outline-text-3" id="text-org9ce3259">
<p>
<i>Haskell</i> es un lenguaje compilado, pero también puede comportarse
como un programa interpretado. Ambas herramientas vienen al
instalar <i>GHC</i> (<i>Glasgow Haskell Compiler</i>), el cuál es el compilador
más usado hoy en día para <i>Haskell</i>.
</p>

<p>
<i>Haskell</i> también cuenta con un administrador de paquetes <i>Cabal</i>,
mediante el cual puedes instalar nuevas bibliotecas y programas. En
particular la utilizaremos más adelante para instalar <i>QuickCheck</i>.
</p>

<p>
Tanto <i>Haskell</i> y <i>Cabal</i> pueden ser instaladas con <code>ghcup</code>, que es un
instalador para éstos y más programas en torno a <i>Haskell</i>, y para
cualquier sistema basado en <i>Unix</i>, y los sistemas operativos <i>Windows</i>
y <i>MacOS</i>.
</p>

<p>
Las instrucciones específicas de cada sistema vienen en la
siguiente página:
</p>

<p>
<a href="https://www.haskell.org/ghcup/install/#installation">https://www.haskell.org/ghcup/install/#installation</a>
</p>
</div>


<div id="outline-container-org7927872" class="outline-4">
<h4 id="org7927872">Requerimientos</h4>
<div class="outline-text-4" id="text-org7927872">
<ul class="org-ul">
<li><p>
Debian &gt;= 12:
</p>

<div class="org-src-container">
<pre class="src src-shell">build-essential curl libffi-dev libffi8 libgmp-dev libgmp10 libncurses-dev libncurses5 libtinfo5
</pre>
</div></li>

<li><p>
Ubuntu &gt;= 23:
</p>

<div class="org-src-container">
<pre class="src src-shell">build-essential curl libffi-dev libffi8ubuntu1 libgmp-dev libgmp10 libncurses-dev
</pre>
</div></li>

<li><p>
Fedora:
</p>

<div class="org-src-container">
<pre class="src src-shell">gcc gcc-c++ gmp gmp-devel make ncurses ncurses-compat-libs xz perl
</pre>
</div></li>

<li><p>
Linux:
</p>

<p>
Investiguen según su distribución cómo instalar los siguientes paquetes:
</p>

<div class="org-src-container">
<pre class="src src-shell">curl g++ gcc gmp make ncurses realpath xz-utils
</pre>
</div></li>

<li><p>
Mac M1:
</p>

<p>
En los sistemas operativos <i>OS X</i> los programas requeridos se
configuran al instalar <code>ghcup</code>, posiblemente tengan que ejecutar
el comando otra vez.
</p>

<p>
En computadoras con <i>M1</i>, deben investiguen cómo instalar <code>llvm</code> con
<code>hombrew</code> y cómo exponerlo en el <code>PATH</code>.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orge4074e2" class="outline-4">
<h4 id="orge4074e2">GHCup</h4>
<div class="outline-text-4" id="text-orge4074e2">
<p>
El comando que debe utilizarse para instalarlo en <i>Linux</i>, <i>macOS</i>,
<i>FreeBSD</i> o <i>WSL2</i> es el siguiente:
</p>

<div class="org-src-container">
<pre class="src src-shell">curl --proto <span style="font-style: italic;">'=https'</span> --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
</pre>
</div>

<p>
(al 29 de enero de 2024, revisen la página si es que ésto cambia).
</p>

<p>
Al terminar la instalación reinicien su <code>shell</code> y el comando <code>ghcup
    tui</code> les abrirá una interfaz de terminal por la cual podrán navegar
por las distintas versiones de <i>GHC</i> y <i>Cabal</i>, sólo asegúrense de
usar las versiones de ambas herramientas respectivamente.
</p>
</div>
</div>

<div id="outline-container-orgee49b98" class="outline-4">
<h4 id="orgee49b98">Administrador de paquetes</h4>
<div class="outline-text-4" id="text-orgee49b98">
<p>
Además de instalar los requerimientos mencionados anteriormente,
los programas que necesitan por lo general llevan los nombres de
<code>ghc</code> y <code>cabal-install</code>.
</p>
</div>
</div>
</div>


<div id="outline-container-orga9ff121" class="outline-3">
<h3 id="orga9ff121">Introducción</h3>
<div class="outline-text-3" id="text-orga9ff121">
<p>
La extensión comúnmente usada para los archivos es <code>.hs</code>
</p>
</div>

<div id="outline-container-orgfebe639" class="outline-4">
<h4 id="orgfebe639">Variables y tipos primitivos</h4>
<div class="outline-text-4" id="text-orgfebe639">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Tipo</th>
<th scope="col" class="org-left">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Int</td>
<td class="org-left">&#x2026;,-2,-1,0,1,2,&#x2026;</td>
</tr>

<tr>
<td class="org-left">Float, Double</td>
<td class="org-left">1.0,-1.25,2.5,&#x2026;</td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">True, False</td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-left">'a','b','c','\n',&#x2026;</td>
</tr>

<tr>
<td class="org-left">Integer</td>
<td class="org-left">&#x2026;,-1,0,1,2,3,&#x2026;</td>
</tr>
</tbody>
</table>

<p>
La creación de variables se puede hacer de la siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">x :: Int
x = 5

x' :: Float
x' = 10.42

y :: Double
y = 10.4283762683

z :: Bool
z = False

c :: Char
c = 'a'
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org3fa4a51"></a>Inmutabilidad<br />
<div class="outline-text-5" id="text-org3fa4a51">
<p>
En <i>Haskell</i> todas las variables son inmutables, es decir, una vez
que se definen, ya no pueden cambiar su valor.
</p>

<p>
Por ejemplo, el siguiente código nos arrojará un error:
</p>

<div class="org-src-container">
<pre class="src src-haskell">num :: Int
num = 1

num :: Int
num = 2
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org74c55c7" class="outline-4">
<h4 id="org74c55c7">Funciones</h4>
<div class="outline-text-4" id="text-org74c55c7">
<p>
Las funciones en <i>Haskell</i> juegan un papel esencial (claro, por eso
es un lenguaje de programación funcional).
</p>

<p>
En matemáticas, una función es una relación de elementos de un
conjunto \(A\) a elementos de un conjunto \(B\), donde un elemento de
\(A\) se "mapea" con un único elemento del conjunto \(B\).
</p>

<p>
Considera una función que eleva al cuadrado un número entero, su
dominio y codominio se denotaría como sigue:
</p>

<p>
\(f:\mathbb{Z}\to\mathbb{Z}\)
</p>

<p>
Se define la función:
</p>

<p>
\(f(x)=x^2\)
</p>

<p>
Y para evaluar la función, sustituyes los parámetros de la función
por un valor:
</p>

<p>
\(f(2)=2^2=4\)
</p>

<p>
\(f(3)=3^2=9\)
</p>

<p>
Análogamente, el tipo de esta función se denotaría como:
</p>

<div class="org-src-container">
<pre class="src src-haskell">f :: Int -&gt; Int
f x = x ^ 2
</pre>
</div>

<p>
Y para evaluar una función:
</p>

<div class="org-src-container">
<pre class="src src-haskell">resultado1 :: Int
resultado1 = f 2

resultado2 :: Int
resultado2 = f 3
</pre>
</div>

<p>
Para abrir el intérprete de <i>Haskell</i>, lo puédes abrir con
<code>ghci</code>. Para cargar un archivo dentro del intérprete, lo puedes
hacer con el comando <code>:t ruta/del/archivo.hs</code>
</p>

<p>
Y puedes evaluar las funciones o variables que definiste.
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; f 12
144
ghci&gt; f 9
81
ghci&gt; resultado1
4
ghci&gt; resultado2
9
</pre>
</div>

<p>
Sin embargo, cabe mencionar que la lógica para funciones
multivariadas cambia, al menos con los tipos.
</p>

<p>
Si ahora queremos hacer una función que recibe dos enteros y
devuelve otro entero (la suma de ambos), lo haríamos de la
siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">suma :: Int -&gt; Int -&gt; Int
suma x y = x + y
</pre>
</div>

<p>
Y para una función de 3 parámetros:
</p>

<div class="org-src-container">
<pre class="src src-haskell">suma3 :: Int -&gt; Int -&gt; Int -&gt; Int
suma3 x y z = x + y + z
</pre>
</div>
</div>
</div>

<div id="outline-container-org07875e7" class="outline-4">
<h4 id="org07875e7">Operadores</h4>
<div class="outline-text-4" id="text-org07875e7">
<p>
Aritméticas:
</p>

<ul class="org-ul">
<li>Suma: <code>+</code></li>
<li>Resta: <code>-</code></li>
<li>Multiplicación: <code>*</code></li>
<li>División (Real): <code>/</code></li>
<li>División (Entera): <code>div</code></li>
<li>Potencia: <code>^</code></li>
</ul>


<p>
Booleanas:
</p>

<ul class="org-ul">
<li>Negación: <code>not</code></li>
<li>Conjunción: <code>&amp;&amp;</code></li>
<li>Disyunción: <code>||</code></li>
</ul>


<p>
Comparación:
</p>

<ul class="org-ul">
<li>Igualdad: <code>==</code></li>
<li>Desigualdad: <code>/=</code></li>
<li>Menor que: <code>&lt;</code></li>
<li>Mayor que: <code>&gt;</code></li>
<li>Menor igual: <code>&lt;=</code></li>
<li>Mayor igual: <code>&gt;=</code></li>
</ul>
</div>
</div>

<div id="outline-container-org0b34376" class="outline-4">
<h4 id="org0b34376">Precedencia</h4>
<div class="outline-text-4" id="text-org0b34376">
<p>
Consideremos la función que dados dos números, suma los cuadrados
de ambos
</p>

<div class="org-src-container">
<pre class="src src-haskell">sumaCuadrados :: Int -&gt; Int -&gt; Int
sumaCuadrados x y = x^2 + y^2
</pre>
</div>

<p>
esta es una definición de función, cabe recordar que los nombres
de funciones y variables deben siempre iniciar con una letra
minúscula seguido de una serie de caracteres alfanuméricos.
</p>

<p>
Las funciones definidas de esta manera como ya vimos, las podemos
utilizar de la siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; suma_cuadrados 2 3
13
</pre>
</div>

<p>
Sin embargo, también es posible aplicar la función de manera
infija, escribiendo el nombre de la función entre dos acentos
graves <code>`</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 2 `suma_cuadrados` 3
13
ghci&gt; 5 `div` 2
2
</pre>
</div>

<p>
Pero haskell también nos deja crear nuestros propios operadores, y
su nombre puede ser cualquier combinación de los siguientes
símbolos:
</p>

<p>
<code>! # $ * + . / &lt; = &gt; ? \ ^ | : - ~ %</code>
</p>

<p>
Para denotar su tipo lo hacemos entre paréntesis:
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) :: Int -&gt; Int -&gt; Int
x &lt;+&lt; y = x^2 + y^2
</pre>
</div>

<p>
También es válido dar la definición de manera prefija escribiendo
el operador entre paréntesis.
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) :: Int -&gt; Int -&gt; Int
(&lt;+&lt;) x y = x^2 + y^2
</pre>
</div>

<p>
Y ya lo podemos utilizar como cualquier otro operador
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 2 &lt;+&lt; 3
13
</pre>
</div>

<p>
De la misma manera es posible utilizar cualquier operador de
manera prefija escribiendo el nombre del operador entre
paréntesis:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; (&lt;+&lt;) 2 3
13
ghci&gt; (+) 2 3
5
ghci&gt; (-) 5 2
3
</pre>
</div>

<p>
Al utilizar notación infija estamos eliminando el uso de
paréntesis
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) ((&lt;+&lt;) 2 3) 4
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">(2 &lt;+&lt; 3) &lt;+&lt; 4
2 &lt;+&lt; 3 &lt;+&lt; 4 -- Por defecto los operadores asocian a la izquierda
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">5/2+3*2/3*(231)
</pre>
</div>

<p>
Sin embargo al combinarlo con otros operadores, posiblemente
queramos que asocie de una forma distinta, y esto lo podemos hacer
con las palabras reservadas <code>infixl</code> e <code>infixr</code>, por ejemplo, la
asociatividas y precedencia de las operaciones aritméticas básicas
se muestra como sigue:
</p>

<div class="org-src-container">
<pre class="src src-haskell">infixl 6 +, -
infixl 7 *, /
</pre>
</div>

<p>
Y si quisiéramos que el operador <code>&lt;+&lt;</code> tuviera la misma precedencia
que la multiplicación y la división, lo tendríamos que definir
como sigue:
</p>

<div class="org-src-container">
<pre class="src src-haskell">infixl 7 &lt;+&lt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 5 * 2 &lt;+&lt; 3 - 1
108
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ff19bf" class="outline-4">
<h4 id="org5ff19bf">Funciones anónimas</h4>
<div class="outline-text-4" id="text-org5ff19bf">
<p>
¿Y si necesitamos hacer una función auxiliar que nada más usaré
una vez, vale la pena definirla si quiera?
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; (\x -&gt; x + 1) 4
5
ghci&gt; (\x y -&gt; x + y) 5 4
9
ghci&gt; (\x y z -&gt; x * y - z) 5 4 3
17
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf09cfa9" class="outline-3">
<h3 id="orgf09cfa9">Listas, definiciones de tipos de dato y coincidencia de patrones</h3>
<div class="outline-text-3" id="text-orgf09cfa9">
<p>
¿Recuerdan la definición inductiva de listas?
</p>

<p>
Listas con elementos de un tipo \(A\):
</p>

<ul class="org-ul">
<li>La lista vacía \([]\), es una lista con elementos de tipo \(A\).</li>

<li>Si \(x\) (cabeza) es un elemento de tipo \(A\) y \(xs\) una lista con
elementos de tipo \(A\), entonces \(x:xs\) es una lista de elementos
de tipo \(A\).</li>

<li>Son todas.</li>
</ul>


<p>
En <i>Haskell</i> también existen las listas bajo la misma semántica de
la definición inductiva.
</p>

<p>
Primero, podemos definir nuestros propios tipos de dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Color = Rojo | Verde | Azul
</pre>
</div>

<p>
<code>Rojo</code>, <code>Verde</code> y <code>Azul</code> son constructores
</p>

<p>
Funcionan similar a una enumeración en java.
</p>

<div class="org-src-container">
<pre class="src src-haskell">favorito :: Color
favorito = Verde
</pre>
</div>

<p>
Estas definiciones de tipos de dato pueden contener otros tipos,
por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Figura = Cuadrado Double
            | Rectangulo Double Double
            | Circulo Double
</pre>
</div>

<p>
<code>Cuadrado</code>, <code>Rectangulo</code> y <code>Circulo</code> son los constructores
</p>

<div class="org-src-container">
<pre class="src src-haskell">cuadrado :: Figura
cuadrado = Cuadrado 4.2

rectangulo :: Figura
rectangulo = Rectangulo 1.2 5.5

circulo :: Figura
circulo = Circulo 2.3
</pre>
</div>

<p>
¿Que pasa si un constructor tiene muchos tipos?
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Alumno = Alumno String String Double Int
</pre>
</div>

<p>
Podemos usar la sintaxis <i>record</i>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Alumno = Alumno { nombre :: String
                     , noCuenta :: String
                     , calif :: Double
                     , asistencias :: Int}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">limon :: Alumno
limon = Alumno { noCuenta = "123456789"
              , calif = 4.8
              , nombre = "Erik Rangel Limón"
              , asistencias = 2 }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; noCuenta erik
"123456789"
</pre>
</div>

<p>
Las definiciones de tipos de dato también pueden utilizar
variables de tipo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Talvez a = Nada | Solo a
</pre>
</div>

<p>
Los tipos de dato también pueden ser definiciones inductivas; por
ejemplo, los números naturales
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Nat = Zero
         | Suc Nat
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">cero :: Nat
cero = Zero

tres :: Nat
tres = Suc (Suc (Suc Zero))

cuatro :: Nat
cuatro = Suc tres
</pre>
</div>

<p>
Ahora, por fin, con las listas, ¿cómo seguimos con la definición?
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Lista a = Vacia -- La lista vacia es una lista de elementos de
                     -- tipo a
             | Cons a (Lista a) -- Un elemento concatenado con otra
                                -- lista de elementos de tipo a es
                                -- una lista con elementos de tipo a
</pre>
</div>

<p>
Afortunadamente <i>haskell</i> ya define este tipo de listas.
</p>

<div class="org-src-container">
<pre class="src src-haskell">data [] a = [] | a : ([] a)
</pre>
</div>

<p>
Por ejemplo, una lista con número enteros
</p>

<div class="org-src-container">
<pre class="src src-haskell">enteros :: [] Int
enteros = 1 : 2 : 3 : 4 : 5 : []
</pre>
</div>

<p>
Pero <i>haskell</i> ofrece una sintaxis más corta para representar listas
(y el tipo de una lista):
</p>

<div class="org-src-container">
<pre class="src src-haskell">enteros2 :: [Double]
enteros2 = [1.24,5.2,7.5,9.3]
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgf069633"></a>Tipos sinónimo<br />
<div class="outline-text-5" id="text-orgf069633">
<p>
Nosotros podemos hacer sinónimos de tipos de dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">type Calificacion = Double
type Clase = [Alumnos]
type Paleta = [Color]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">alumnos1 :: Clase
alumnos1 = [erik, juan, alberto]
</pre>
</div>
</div>
</li>
<li><a id="org0fd0d81"></a>Strings<br />
<div class="outline-text-5" id="text-org0fd0d81">
<p>
Sí, sí existen cadenas en haskell, pero éstas se definen como un
sinónimo de tipo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">type String = [Char]
</pre>
</div>

<p>
Y para escribir cadenas de texto, haskell nos da la posibilidad
de usar <code>""</code> para representarlas.
</p>

<p>
<b>No olviden que las comillas simples <code>''</code> denotan caracteres</b>
</p>
</div>
</li>
</ul>

<div id="outline-container-orgd015a4f" class="outline-4">
<h4 id="orgd015a4f">Condicionales</h4>
<div class="outline-text-4" id="text-orgd015a4f">
<p>
Como en cualquier lenguaje de programación, tenemos expresiones
condicionales para manejar casos en los que se cumpla una
propiedad:
</p>

<p>
La sintaxis que tiene es la siguiente:
</p>

<p>
<code>if &lt;expresión booleana&gt; then &lt;expr de tipo A&gt; else &lt;expr de tipo A&gt;</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 4 &lt; 5 then "Primer caso" else "Segundo caso"
"Primer caso"  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 4 &lt; 3 then "Primer caso" else "Segundo caso"
"Segundo caso"
</pre>
</div>

<p>
Es importante que los resultados tanto del <code>then</code> como del <code>else</code> sean
del mismo tipo, si no, nos va a dar error:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 3 &lt; 4 then "Primer caso" else 2.5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">mimax :: Int -&gt; Int -&gt; Int
mimax n m = if n &gt; m then n else m
</pre>
</div>

<p>
La otra opción que tenemos para manejar casos es con guardias, y
éstas son exclusivas cuando se definen funciones.
</p>

<div class="org-src-container">
<pre class="src src-haskell">compara :: Int -&gt; Int -&gt; String
compara n m | n &lt; m = "El primero es menor que el segundo"
            | n == m = "Son iguales"
            | otherwise = "El primero es mayor que el segundo"
</pre>
</div>

<p>
Estas suelen reducir la sintaxis cuando son más las condiciones
que se deben revisar, sin embargo, debes cerciorarte de ser
completo con tus condiciones, es decir, que al menos una condición
se cumpla.
</p>

<p>
Para asegurar esto siempre es recomendable usar poner un caso para
cuando ninguna de las anteriores se haya cumplido.
</p>

<div class="org-src-container">
<pre class="src src-haskell">compara2 :: Int -&gt; Int -&gt; String
compara2 n m | n &lt; m = "El primero es menor que el segundo"
             | n == m = "Son iguales"
             | otherwise = "El primero es mayor que el segundo"
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ab349c" class="outline-4">
<h4 id="org8ab349c">Coincidencia de patrones</h4>
<div class="outline-text-4" id="text-org8ab349c">
<p>
Éste se le conoce en inglés como <i>pattern matching</i> y en español
muchas veces lo encontrarán como <i>caza de patrones</i>.
</p>

<p>
¿Cómo podemos utilizar funciones con éstos tipos de dato?
</p>

<div class="org-src-container">
<pre class="src src-haskell">describe :: Color -&gt; String
describe color = case color of
                   Rojo -&gt; "El color es rojo"
                   Verde -&gt; "El color es verde"
                   Azul -&gt; "El color es azul"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">describe2 :: Color -&gt; String
describe2 Rojo = "El color es rojo"
describe2 Verde = "El color es verde"
describe2 Azul = "El color es azul"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">predecesor :: Nat -&gt; Nat
predecesor Zero = Zero
predecesor (Suc n) = n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ceroUno :: Nat -&gt; Nat
ceroUno Zero = Suc Zero
ceroUno n = n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">esZero :: Nat -&gt; Bool
esZero Zero = True
esZero _ = False
</pre>
</div>

<p>
¿Ahora, cómo hacemos coincidencia de patrones con listas?
</p>

<div class="org-src-container">
<pre class="src src-haskell">alMenosUno :: [a] -&gt; Bool
alMenosUno [] = False
alMenosUno _ = True
</pre>
</div>

<p>
Si queremos obtener la cabeza de una lista:
</p>

<div class="org-src-container">
<pre class="src src-haskell">cabeza :: [a] -&gt; a
cabeza (x:xs) = x
</pre>
</div>

<p>
Si queremos obtener la cola de una lista:
</p>

<div class="org-src-container">
<pre class="src src-haskell">cola :: [a] -&gt; [a]
cola (x:xs) = xs
</pre>
</div>

<p>
Suma en naturales:
</p>

<p>
\(+(0,x)=x\)
</p>

<p>
\(+(s(n), m)=s(n+m)\)
</p>

<div class="org-src-container">
<pre class="src src-haskell">sumaNats :: Nat -&gt; Nat -&gt; Nat
sumaNats Zero m = m
sumaNats (Suc n) m = Suc (sumaNats n m)
</pre>
</div>

<p>
Niveles en un árbol:
</p>

<p>
Consideremos la definición de árboles binarios que viene en su
primera práctica:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Bin a = Vacio
           | Nodo a (Bin a) (Bin a) deriving Show
</pre>
</div>

<p>
Ahora queremos una función que nos regrese el número de hojas que hay en un árbol.
</p>

<p>
Una hoja es un árbol cuyos hijos izquierdo y derecho son vacíos.
</p>

<div class="org-src-container">
<pre class="src src-haskell">hojas :: Bin a -&gt; Int
hojas Vacio = 0
hojas (Nodo a Vacio Vacio) = 1
hojas (Nodo a l r) = hojas l + hojas r
</pre>
</div>

<p>
El nivel de un árbol:
</p>

<div class="org-src-container">
<pre class="src src-haskell">nivel :: Bin a -&gt; Int
nivel Vacio = -1
nivel (Nodo a l r) = 1 + max (nivel l) (nivel r)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1443e3" class="outline-4">
<h4 id="orgb1443e3">Funciones de orden superior</h4>
<div class="outline-text-4" id="text-orgb1443e3">
<p>
Una función de orden superior, es una función que puede recibir
como parámetro otra función.
</p>

<p>
Por ejemplo, las derivadas e integrales son funciones que reciben
como parámetro otra función.
</p>

<p>
En caso de <i>haskell</i> no vamos a derivar ni nada, pero utilizaremos
funciones de orden superior.
</p>

<p>
Por ejemplo, ¿qué pasa si queremos sumar uno a todos los números
de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">aumenta :: [Int] -&gt; [Int]
aumenta [] = []
aumenta (x:xs) = x+1 : aumenta xs
</pre>
</div>

<p>
Y ahora, ¿si lo que queremos es elevar al cuadrado todos los
números de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">eleva :: [Int] -&gt; [Int]
eleva [] = []
eleva (x:xs) = x^2 : eleva xs
</pre>
</div>

<p>
Las dos funciones son muy similares, ¿es posible generalizarlas?
</p>

<p>
Sí, con funciones de orden superior:
</p>

<div class="org-src-container">
<pre class="src src-haskell">mimap :: (a -&gt; b) -&gt; [a] -&gt; [b]
mimap f [] = []
mimap f (x:xs) = f x : mimap f xs
</pre>
</div>

<p>
Entonces, ¿cómo elevamos al cuadrado todos los elementos de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; mimap (\x -&gt; x ^ 2) [1,2,3,4,5]
[1,4,9,16,25]
ghci&gt; mimap (\x -&gt; x + 1) [1,2,3,4,5]
[2,3,4,5,6]
</pre>
</div>

<p>
Ahora, qué si queremos 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge3eb640" class="outline-2">
<h2 id="orge3eb640">Lógica proposicional en Haskell</h2>
<div class="outline-text-2" id="text-orge3eb640">
<div class="org-src-container">
<pre class="src src-haskell">type Name = String

data Prop = Var Name | Val Bool
          | Neg Prop
          | Prop #||# Prop
          | Prop #&amp;&amp;# Prop
          | Prop #-&gt;# Prop
          | Prop #&lt;&gt;# Prop

infixl 7 #&amp;&amp;#, #||#
infixr 8 #-&gt;#, #&lt;&gt;#
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b3c920" class="outline-2">
<h2 id="org8b3c920">Prolog</h2>
<div class="outline-text-2" id="text-org8b3c920">
<p>
<i>Prolog</i> es un lenguaje de programación dentro del paradigma declarativo.
</p>

<p>
Es un lenguaje lógico, en donde un programa es un conjunto de hechos
y reglas, que definen relaciones, de tal forma que un cómputo se
vuelve una consulta en éste programa.
</p>
</div>

<div id="outline-container-orge4d5615" class="outline-3">
<h3 id="orge4d5615">Predicados y constantes</h3>
<div class="outline-text-3" id="text-orge4d5615">
<p>
En <i>Prolog</i> podemos definir predicados sobre constantes concretas, lo
único que se requiere es que tanto el nombre del predicado como el
nombre de nuestra constante comience con minúscula.
</p>

<p>
Por ejemplo, el siguiente predicado nos dice que su parámetro es escritor.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">escritor</span>(vargas_llosa). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Mario Vargas Llosa es un escritor</span>
<span style="font-weight: bold;">escritor</span>(carlos_fuentes). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Carlos Fuentes es un escritor</span>
<span style="font-weight: bold;">escritor</span>(ryu_murakami). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Ryu Murakami es un escritor</span>

<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Sobra decir que los comentarios en prolog se denotan con el s&#237;mbolo</span>
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">de %</span>
</pre>
</div>


<p>
Éstos predicados pueden tener distinta aridad para dar mejor
descripciones.
</p>

<p>
Por ejemplo, el siguiente predicado es <code>escribio(X,Y)</code> y nos dice que
el autor <code>X</code> escribió <code>Y</code>.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">escribio</span>(vargas_llosa, felicidad_en_la_otra_esquina).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Mario Vargas Llosa escribi&#243;: La felicidad en la otra esquina</span>
<span style="font-weight: bold;">escribio</span>(vargas_llosa, los_cachorros).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Mario Vargas Llosa escribi&#243;: Los cachorros</span>
<span style="font-weight: bold;">escribio</span>(carlos_fuentes, gringo_viejo).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Carlos Fuentes escribi&#243;: Gringo Viejo</span>
<span style="font-weight: bold;">escribio</span>(carlos_fuentes, aura).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Carlos Fuentes escribi&#243;: Aura</span>
<span style="font-weight: bold;">escribio</span>(ryu_murakami, azul_casi_transparente).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Ryu Murakami escribi&#243;: Azul casi transparente</span>
<span style="font-weight: bold;">escribio</span>(erik_rangel, notas_lab).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Erik Rangel escribi&#243; las notas de laboratorio</span>
</pre>
</div>

<p>
Y así, podemos especificar más propiedades sobre nuestras constantes.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">latinoamericano</span>(vargas_llosa). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Mario Vargas Llosa es latinoamericano</span>
<span style="font-weight: bold;">latinoamericano</span>(carlos_fuentes). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Carlos Fuentes es latinoamericano</span>
<span style="font-weight: bold;">latinoamericano</span>(erik_rangel). <span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">Erik Rangel es latinoamericano</span>

<span style="font-weight: bold;">reconocimiento</span>(los_cachorros).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">El libro "Los cachorros" tuvo reconocimiento internacional</span>
<span style="font-weight: bold;">reconocimiento</span>(aura).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">El libro "Aura" tuvo reconocimiento internacional</span>
<span style="font-weight: bold;">reconocimiento</span>(azul_casi_transparente).
<span style="font-weight: bold; font-style: italic;">%% </span><span style="font-weight: bold; font-style: italic;">El libro "Azul casi transparente" tuvo reconocimiento internacional</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org849a722" class="outline-3">
<h3 id="org849a722">Consultas</h3>
<div class="outline-text-3" id="text-org849a722">
<p>
Como mencionamos anteriormente, en prolog sólo definimos hechos y
reglas, tal y como lo hicimos en la sección anterior.
</p>

<p>
Toda esta información será nuestra base de conocimientos, y ésta la
pueden guardar en un archivo con terminación <code>.pl</code>
</p>

<p>
Podemos interpretar ésta base de conocimientos con la orden <code>swipl
   archivo.pl</code>, y nos saldrá un prompt como el siguiente:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?-
</pre>
</div>

<p>
Aquí podemos hacer consultas sobre cosas que definimos en nuestra
base de conocimientos.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- escritor(carlos_fuentes).
true.
?- escritor(erik_rangel).
false.
?- escribio(ryu_murakami, azul_casi_transparente).
true.
?- escribio(ryu_murakami, aura).
true.
</pre>
</div>
</div>
</div>

<div id="outline-container-org5660c27" class="outline-3">
<h3 id="org5660c27">Condiciones y Variables</h3>
<div class="outline-text-3" id="text-org5660c27">
<p>
Podemos dar propiedades más específicas usando condiciones, por
ejemplo, si queremos expresar la propiedad:
</p>

<p>
<i>Si un escritor latinoamericano escribió un libro que tuvo</i>
<i>reconocimiento internacional, entonces pertenece al boom
latinoamericano.</i>
</p>

<p>
Para expresar ésto en prolog lo podríamos hacer de la siguiente
forma:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">boom_lat</span>(<span style="font-weight: bold; font-style: italic;">X</span>) :- escritor(<span style="font-weight: bold; font-style: italic;">X</span>),
               latinoamericano(<span style="font-weight: bold; font-style: italic;">X</span>),
               escribio(<span style="font-weight: bold; font-style: italic;">X</span>,<span style="font-weight: bold; font-style: italic;">Y</span>),
               reconocimiento(<span style="font-weight: bold; font-style: italic;">Y</span>).
</pre>
</div>

<p>
Las condiciones tienen la siguiente forma:
</p>

<p>
<code>&lt;conclusión&gt; :- &lt;condiciones&gt;.</code>
</p>

<p>
Y también con ésto introducimos a las variables, las cuales tienen
la única condición de que deben inciar con mayúscula.
</p>

<p>
Ahora, con ésto prolog nos puede responder nuevas consultas:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- boom_lat(carlos_fuentes).
true.
?- boom_lat(erik_rangel).
false.
</pre>
</div>

<p>
También con la introducción de variables, podemos hacer consultas
más útiles, por ejemplo, podríamos preguntarle a prolog qué autores
pertenecen al boom latinoamericano.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- boom_lat(<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = vargas_llosa
</pre>
</div>

<p>
Al introducir ésta consulta, prolog nos regresa un posible valor
para la <code>X</code> que le pasamos, sin embargo, no nos devuelve al prompt,
ésto quiere decir que prolog puede intentar obtener otro posible
valor para <code>X</code>.
</p>

<p>
Si la <code>X</code> que nos dió es suficiente para nosotros, entonces podemos
presionar <code>Enter</code> o <code>.</code> para volver al prompt.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- boom_lat(<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = vargas_llosa.
?-
</pre>
</div>

<p>
Si queremos ver el otro resultado, en su lugar podemos presionar <code>;</code>
hasta que ya no haya más resultados.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- boom_lat(<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = vargas_llosa <span style="font-weight: bold;">;</span>
<span style="font-weight: bold; font-style: italic;">X</span> = carlos_fuentes <span style="font-weight: bold;">;</span>
false.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd95c9c6" class="outline-3">
<h3 id="orgd95c9c6">Backtracking</h3>
<div class="outline-text-3" id="text-orgd95c9c6">
<p>
¿Por qué al final de la última consulta nos sale <code>false</code>?
</p>

<p>
Ésto es por la forma en la que prolog hace sus consultas, que es
por medio de <i>backtracking</i>. Esta forma de realizar operaciones
permite a prolog explorar todas las posibilidades hasta encontrar
un resultado, de tal forma que al encontrar un resultado que no es
válido (o necesitar otro posible resultado), prolog pueda regresar
en las decisiones que tomó y elegir otra posibilidad
</p>

<p>
<i>Prolog</i> permite ver cómo se realiza cada una de estas decisiones al
escribir el predicado <code>trace</code>.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- trace.
true.

<span style="font-weight: bold;">[</span>trace<span style="font-weight: bold;">]</span>  ?-
</pre>
</div>

<p>
Vemos como cambia el prompt para recordar que la opción <code>trace</code> está
activada.
</p>

<p>
Y ahora si hacemos una consulta como lo hacíamos antes, nos va a
mostrar los pasos intermedios que se hacen antes de devolver un
resultado.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">[</span>trace<span style="font-weight: bold;">]</span>  ?- boom_lat(<span style="font-weight: bold; font-style: italic;">X</span>).
   <span style="font-weight: bold; font-style: italic;">Call</span>: (12) boom_lat(<span style="font-weight: bold; font-style: italic;">_5940</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) escritor(<span style="font-weight: bold; font-style: italic;">_5940</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escritor(vargas_llosa) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) latinoamericano(vargas_llosa) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) latinoamericano(vargas_llosa) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) escribio(vargas_llosa, <span style="font-weight: bold; font-style: italic;">_10454</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escribio(vargas_llosa, felicidad_en_la_otra_esquina) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) reconocimiento(felicidad_en_la_otra_esquina) ? creep
   <span style="font-weight: bold; font-style: italic;">Fail</span>: (13) reconocimiento(felicidad_en_la_otra_esquina) ? creep
   <span style="font-weight: bold; font-style: italic;">Redo</span>: (13) escribio(vargas_llosa, <span style="font-weight: bold; font-style: italic;">_10454</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escribio(vargas_llosa, los_cachorros) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) reconocimiento(los_cachorros) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) reconocimiento(los_cachorros) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (12) boom_lat(vargas_llosa) ? creep
<span style="font-weight: bold; font-style: italic;">X</span> = vargas_llosa <span style="font-weight: bold;">;</span>
   <span style="font-weight: bold; font-style: italic;">Redo</span>: (13) escritor(<span style="font-weight: bold; font-style: italic;">_5940</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escritor(carlos_fuentes) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) latinoamericano(carlos_fuentes) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) latinoamericano(carlos_fuentes) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) escribio(carlos_fuentes, <span style="font-weight: bold; font-style: italic;">_22466</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escribio(carlos_fuentes, gringo_viejo) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) reconocimiento(gringo_viejo) ? creep
   <span style="font-weight: bold; font-style: italic;">Fail</span>: (13) reconocimiento(gringo_viejo) ? creep
   <span style="font-weight: bold; font-style: italic;">Redo</span>: (13) escribio(carlos_fuentes, <span style="font-weight: bold; font-style: italic;">_22466</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escribio(carlos_fuentes, aura) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) reconocimiento(aura) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) reconocimiento(aura) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (12) boom_lat(carlos_fuentes) ? creep
<span style="font-weight: bold; font-style: italic;">X</span> = carlos_fuentes <span style="font-weight: bold;">;</span>
   <span style="font-weight: bold; font-style: italic;">Redo</span>: (13) escritor(<span style="font-weight: bold; font-style: italic;">_5940</span>) ? creep
   <span style="font-weight: bold; font-style: italic;">Exit</span>: (13) escritor(ryu_murakami) ? creep
   <span style="font-weight: bold; font-style: italic;">Call</span>: (13) latinoamericano(ryu_murakami) ? creep
   <span style="font-weight: bold; font-style: italic;">Fail</span>: (13) latinoamericano(ryu_murakami) ? creep
   <span style="font-weight: bold; font-style: italic;">Fail</span>: (12) boom_lat(<span style="font-weight: bold; font-style: italic;">_5940</span>) ? creep
false.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf716277" class="outline-3">
<h3 id="orgf716277">Números y Operadores</h3>
<div class="outline-text-3" id="text-orgf716277">
<p>
Como comúnmente tenemos en los lenguajes de programación, los operadores aritméticos son:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">suma</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">X</span> + <span style="font-weight: bold; font-style: italic;">Y</span>).
<span style="font-weight: bold;">resta</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">X</span> - <span style="font-weight: bold; font-style: italic;">Y</span>).
<span style="font-weight: bold;">multiplicacion</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">X</span> * <span style="font-weight: bold; font-style: italic;">Y</span>).
<span style="font-weight: bold;">division</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">X</span> / <span style="font-weight: bold; font-style: italic;">Y</span>).
</pre>
</div>

<p>
Los operadores de comparación:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">igualdad</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> =:= <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">desigualdad</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> =\= <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">menor_que</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> &lt; <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">mayor_que</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> &gt; <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">menor_igual</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> =&lt; <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">mayor_igual</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>) :- <span style="font-weight: bold; font-style: italic;">X</span> &gt;= <span style="font-weight: bold; font-style: italic;">Y</span>.
</pre>
</div>
</div>

<div id="outline-container-orgbc3920e" class="outline-4">
<h4 id="orgbc3920e">Negación como falla</h4>
<div class="outline-text-4" id="text-orgbc3920e">
<p>
En <i>Prolog</i> toda proposición que no haya sido escrita en la base de
conocimientos (o no pueda ser determinada) será considerada como
<code>false</code>, pero cabe decir que este resultado no es definitivo, sólo
nos dice que no se encontró una forma de demostrarlo.
</p>

<p>
Por ejemplo, nostros no le dijimos a <i>Prolog</i> que <i>Shakespeare</i> fue un
escritor, por lo que tendremos como resultado de una consulta así
lo siguiente:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- escritor(shakespeare).
false.
?-
</pre>
</div>

<p>
Nos dirá que esto es falso a pesar de que nosotros sepamos que
<i>Shakespeare</i> sí fue un escritor.
</p>

<p>
Por ello no existe como tal un operación de negación en prolog,
pero sí tendremos un operador para ver si algo <i>no es demostrable</i>.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">no_escritor</span>(<span style="font-weight: bold; font-style: italic;">X</span>) :- \+ escritor(<span style="font-weight: bold; font-style: italic;">X</span>).
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e5da61" class="outline-4">
<h4 id="org4e5da61">Unificación</h4>
<div class="outline-text-4" id="text-org4e5da61">
<p>
En prolog tenemos dos operadores distintos para verificar que dos
expresiones son unificables:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">suma2</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">RES</span> = <span style="font-weight: bold; font-style: italic;">X</span> + <span style="font-weight: bold; font-style: italic;">Y</span>.
<span style="font-weight: bold;">suma3</span>(<span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Y</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">X</span> + <span style="font-weight: bold; font-style: italic;">Y</span>.
</pre>
</div>

<p>
La primera de ellas, sólo podrá decir si <code>RES</code> en efecto unifica con
la expresión <code>X+Y</code>, y de hecho esta unificación es la que se hacía
cuando explicamos los operadores; mientras que la segundo podrá
decir cuando <code>RES</code> sea unificable con el resultado de la expresión
<code>X+Y</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org559a450" class="outline-3">
<h3 id="org559a450">Ejemplos</h3>
<div class="outline-text-3" id="text-org559a450">
<p>
Calcular la suma de todos los números naturales menores a un \(n\):
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">suma_gauss</span>(0, 0).
<span style="font-weight: bold;">suma_gauss</span>(<span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">N</span> &gt;= 0,
                      <span style="font-weight: bold; font-style: italic;">N1</span> is <span style="font-weight: bold; font-style: italic;">N</span> - 1,
                      suma_gauss(<span style="font-weight: bold; font-style: italic;">N1</span>, <span style="font-weight: bold; font-style: italic;">R1</span>),
                      <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">N</span> + <span style="font-weight: bold; font-style: italic;">R1</span>.
</pre>
</div>

<p>
Y le podemos preguntar a <code>prolog</code> el resultado
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- suma_gauss(5,<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = 15 <span style="font-weight: bold;">;</span>
false.
</pre>
</div>

<p>
Como vemos, <code>prolog</code> piensa que puede haber otro resultado, sin
embargo al nosotros tener el valor de la variable <code>RES</code> es porque ya
sabemos el resultado final, y no necesitamos más resultados.
</p>

<p>
Para este tipo de operaciones es necesario indicarle a <code>prolog</code> que
no existen más resultados, y para ello podemos utilizar el operador
de corte después de que se sepa que ya hay un resultado.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">suma_gauss</span>(0, 0) :- <span style="font-weight: bold;">!</span>.
<span style="font-weight: bold;">suma_gauss</span>(<span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">N</span> &gt;= 0,
                      <span style="font-weight: bold; font-style: italic;">N1</span> is <span style="font-weight: bold; font-style: italic;">N</span> - 1,
                      suma_gauss(<span style="font-weight: bold; font-style: italic;">N1</span>, <span style="font-weight: bold; font-style: italic;">R1</span>),
                      <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">N</span> + <span style="font-weight: bold; font-style: italic;">R1</span>,
                      <span style="font-weight: bold;">!</span>.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-prolog">?- suma_gauss(5,<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = 15.
</pre>
</div>

<p>
Ahora, podemos hacer un predicado que calcula el factorial de un número.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">factorial</span>(0,1) :- <span style="font-weight: bold;">!</span>.
<span style="font-weight: bold;">factorial</span>(<span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">N</span> &gt;= 0,
                     <span style="font-weight: bold; font-style: italic;">N1</span> is <span style="font-weight: bold; font-style: italic;">N</span> - 1,
                     factorial(<span style="font-weight: bold; font-style: italic;">N1</span>, <span style="font-weight: bold; font-style: italic;">R1</span>),
                     <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">N</span> * <span style="font-weight: bold; font-style: italic;">R1</span>,
                     <span style="font-weight: bold;">!</span>.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-prolog">?- factorial(5,<span style="font-weight: bold; font-style: italic;">X</span>).
<span style="font-weight: bold; font-style: italic;">X</span> = 120.
</pre>
</div>

<p>
Un predicado que nos da el n-ésimo número fibonacci.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">fibonacci</span>(0,0) :- <span style="font-weight: bold;">!</span>.
<span style="font-weight: bold;">fibonacci</span>(1,1) :- <span style="font-weight: bold;">!</span>.
<span style="font-weight: bold;">fibonacci</span>(<span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; font-style: italic;">RES</span>) :- <span style="font-weight: bold; font-style: italic;">N</span> &gt; 1,
                     <span style="font-weight: bold; font-style: italic;">N1</span> is <span style="font-weight: bold; font-style: italic;">N</span> - 1,
                     <span style="font-weight: bold; font-style: italic;">N2</span> is <span style="font-weight: bold; font-style: italic;">N</span> - 2,
                     fibonacci(<span style="font-weight: bold; font-style: italic;">N1</span>, <span style="font-weight: bold; font-style: italic;">R1</span>),
                     fibonacci(<span style="font-weight: bold; font-style: italic;">N2</span>, <span style="font-weight: bold; font-style: italic;">R2</span>),
                     <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">R1</span> + <span style="font-weight: bold; font-style: italic;">R2</span>,
                     <span style="font-weight: bold;">!</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f183d2" class="outline-3">
<h3 id="org5f183d2">Listas y comodines</h3>
<div class="outline-text-3" id="text-org5f183d2">
<p>
Las listas se definen inductivamente bajo la definición recursiva convencional:
</p>

<p>
Podemos tener la lista vacía, y ésta se representa como <code>[]</code>
</p>

<p>
Podemos tener una lista con cabeza <code>X</code> y cola <code>XS</code>, y se representa
como <code>[X|XS]</code>.
</p>

<p>
También podemos construir listas con al menos un primer y segundo
elemento; éste se escribe como <code>[X,Y|XS]</code>, y así para cualquier
cantidad de elementos.
</p>

<p>
Por ejemplo, haremos un predicado que nos calcula la longitud de una
lista:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">longitud</span>(<span style="font-weight: bold;">[]</span>,0).
<span style="font-weight: bold;">longitud</span>(<span style="font-weight: bold;">[</span><span style="font-weight: bold; font-style: italic;">_</span><span style="font-weight: bold;">|</span><span style="font-weight: bold; font-style: italic;">XS</span><span style="font-weight: bold;">]</span>,<span style="font-weight: bold; font-style: italic;">RES</span>) :- longitud(<span style="font-weight: bold; font-style: italic;">XS</span>, <span style="font-weight: bold; font-style: italic;">N</span>),
                        <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">N</span> + 1.
</pre>
</div>

<p>
En este caso nótese que no es necesario utilizar el operador de
corte, pues una lista sólo va a unificar con sólamente uno de los
dos casos que definimos, o la lista vacía, o la lista con al menos
un elemento, por lo que no va a intentar más caminos después de
devolver el primer resultado.
</p>

<p>
Ahora, un predicado que nos da la concatenación de dos listas:
</p>

<div class="org-src-container">
<pre class="src src-haskell">concatena([],YS,YS).
concatena([X|XS],YS,[X|R1]) :- concatena(XS,YS,R1).
</pre>
</div>

<p>
Un predicado que nos da la reversa:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">reversa</span>(<span style="font-weight: bold;">[]</span>,<span style="font-weight: bold;">[]</span>).
<span style="font-weight: bold;">reversa</span>(<span style="font-weight: bold;">[</span><span style="font-weight: bold; font-style: italic;">X</span><span style="font-weight: bold;">|</span><span style="font-weight: bold; font-style: italic;">XS</span><span style="font-weight: bold;">]</span>,<span style="font-weight: bold; font-style: italic;">RES</span>) :- reversa(<span style="font-weight: bold; font-style: italic;">XS</span>,<span style="font-weight: bold; font-style: italic;">R1</span>),
                       concatena(<span style="font-weight: bold; font-style: italic;">R1</span>,<span style="font-weight: bold;">[</span><span style="font-weight: bold; font-style: italic;">X</span><span style="font-weight: bold;">]</span>,<span style="font-weight: bold; font-style: italic;">RES</span>).
</pre>
</div>

<p>
Un predicado que da la suma de una lista de números:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="font-weight: bold;">suma</span>(<span style="font-weight: bold;">[]</span>,0).
<span style="font-weight: bold;">suma</span>(<span style="font-weight: bold;">[</span><span style="font-weight: bold; font-style: italic;">X</span><span style="font-weight: bold;">|</span><span style="font-weight: bold; font-style: italic;">XS</span><span style="font-weight: bold;">]</span>,<span style="font-weight: bold; font-style: italic;">RES</span>) :- suma(<span style="font-weight: bold; font-style: italic;">XS</span>, <span style="font-weight: bold; font-style: italic;">R1</span>),
                    <span style="font-weight: bold; font-style: italic;">RES</span> is <span style="font-weight: bold; font-style: italic;">R1</span> + <span style="font-weight: bold; font-style: italic;">X</span>.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Erik Rangel Limón</p>
<p class="date">Created: 2024-08-13 Tue 14:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
