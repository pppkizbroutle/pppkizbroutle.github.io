<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-13 Tue 14:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lenguajes de programación</title>
<meta name="author" content="Erik Rangel Limón" />
<meta name="generator" content="Org Mode" />
<style type="text/css">/* Base */html,body {    background-color: #222;    min-height: 100%;    line-height: 1.5;}body {    color: #fafafa;    font-family: "Courier New";}::selection {    background-color:  #2ecc40;    color: white;}/* Responsive content positioning */@media only screen and (min-width: 1020px) /* Large screens */{    body{        padding: 10vh 25vw;    }}@media only screen and (max-width: 1020px) and (min-width: 750px) /* Small screens */{    body{        padding: 5vh 10vw;    }}@media only screen and (max-width: 750px) /* Small screens */{    body{        padding: 2vh 5vw;    }}/* Headers */h1{font-size: 2.5rem;}h2{font-size: 1.7rem;}h1 > .subtitle, h3, h4, h5, h6{font-size: 1.3rem;}.title{    margin-bottom: 2.5rem;}/* Padding & Margin */* {margin: 0; padding: 0;}pre, blockquote, ul, ol, p, table{    margin: 1rem 0;}h1, h2{margin-top: 2rem; line-height: 2rem;}h3, h4, h5, h6{margin-top: 1rem;}/* Links  */a, a:visited {    color: #01ff70;    text-decoration: underline;}a:hover, a:focus, a:active {    color: #2ecc40;}/* Code */pre {    font-family: "Courier New";    padding: .5rem;    background-color: #333;    padding: 0.5rem;    border-radius: 0.2rem;    font-size: 0.9rem;    color: #EEE;    overflow-x: auto;}.org-keyword{    color: #01ff70;}.org-rainbow-delimiters-depth-1{    color: #2ecc40;}.org-rainbow-delimiters-depth-2{    color: #01ff70;}/* Blockquotes */blockquote {    border-left: 3px solid #01ff70;    padding-left: 1rem;}li{    list-style-position: inside;}/* Tags */.tag{    margin-top: 0.5rem;    display: block;    color: white;    font-size: var(--font-size-xsmall);}.tag > span{		font-weight: 400;    font-size: 0.8rem;    background-color: #444;    text-transform: uppercase;    border-radius: 2px;    width: fit-content;    height: auto;    padding: 1px 5px;}/* Keywords */.todo{    color: #2ecc40;}.done{    color: #444;}/* Overflows */.outline-text-2, .outline-text-3, .outline-text-4{	  max-width: 100%;	  overflow-x: auto;}/* Table */tr:nth-child(even) {    background-color: #333;}th, td{    padding: 0.5rem;    text-align: center;}.underline{    text-decoration: underline;}img{    max-width: 100%;    height: auto;}</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Lenguajes de programación</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org192a657">Dinámica del laboratorio</a>
<ul>
<li><a href="#org7161e53">Prácticas</a></li>
</ul>
</li>
<li><a href="#orgd9b4f5d">Haskell</a>
<ul>
<li><a href="#org0dc8c68">Instalación</a>
<ul>
<li><a href="#orgfc79059">Requerimientos</a></li>
<li><a href="#orga7675e9">GHCup</a></li>
</ul>
</li>
<li><a href="#org574dcd9">QuickCheck y Happy</a></li>
<li><a href="#org6b1ef46">Introducción</a>
<ul>
<li><a href="#org48e9a7d">Variables y tipos primitivos</a></li>
<li><a href="#org392cbdb">Funciones</a></li>
<li><a href="#orga5cc64f">Operadores</a></li>
<li><a href="#org48d4ca5">Precedencia</a></li>
<li><a href="#orgb7d69b7">Funciones anónimas</a></li>
</ul>
</li>
<li><a href="#org1c07ad2">Listas, definiciones de tipos de dato y coincidencia de patrones</a>
<ul>
<li><a href="#org125bab1">Condicionales</a></li>
<li><a href="#orgbb7bb67">Coincidencia de patrones</a></li>
<li><a href="#orgbb2f420">Funciones de orden superior</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org325903c">Clases</a></li>
<li><a href="#org148891a">Práctica 1</a></li>
</ul>
</div>
</div>
<p>
<a href="../index.html">Anterior</a>
</p>

<div id="outline-container-org192a657" class="outline-2">
<h2 id="org192a657">Dinámica del laboratorio</h2>
<div class="outline-text-2" id="text-org192a657">
<p>
Para este curso todas las prácticas serán hechas en <i>Haskell</i>, y para
la gran mayoría de ellas utilizaremos una biblioteca llamada <i>Happy</i>.
</p>

<p>
<i>Happy</i> es una herramienta para generar analizadores sintácticos en
<i>Haskell</i>. Esta herramienta la utilizamos ya que el análisis
sintáctico es un tema muy extenso, el cual verán a lujo de detalle
en su materia de compiladores, por lo que por este curso nos los
vamos a ahorrar.
</p>
</div>

<div id="outline-container-org7161e53" class="outline-3">
<h3 id="org7161e53">Prácticas</h3>
<div class="outline-text-3" id="text-org7161e53">
<p>
Las prácticas por lo general serán varios archivos, el cuál algunos
de ellos serán los <i>Tests</i> y que no deberán modificar.
</p>

<p>
Los <i>Tests</i> estarán hechos en <i>QuickCheck</i> y el que pasen todas las
propiedades tentativamente hará que tengan 10.
</p>

<p>
Digo tentativamente ya que tendrán que defender su solución a la
práctica en un README que tienen que entregar en su repositorio.
</p>

<p>
Pedimos el README para evitar las copias tanto entre compañeros
como de páginas de internet o IA.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd9b4f5d" class="outline-2">
<h2 id="orgd9b4f5d">Haskell</h2>
<div class="outline-text-2" id="text-orgd9b4f5d">
<p>
Se propone éste lenguaje pues cuenta con transparencia referencial,
lo que garantiza que se pueda reemplazar una expresión con otra de
igual valor sin cambiar el significado de éste. Como consecuencia,
una función siempre producirá el mismo resultado para una entrada
dada, por lo que es posible construir, razonar y manipular programas
funcionales como si se tratasen de una expresión matemática.
</p>
</div>

<div id="outline-container-org0dc8c68" class="outline-3">
<h3 id="org0dc8c68">Instalación</h3>
<div class="outline-text-3" id="text-org0dc8c68">
<p>
<i>Haskell</i> es un lenguaje compilado, pero también puede comportarse
como un programa interpretado. Ambas herramientas vienen al
instalar <i>GHC</i> (<i>Glasgow Haskell Compiler</i>), el cuál es el compilador
más usado hoy en día para <i>Haskell</i>.
</p>

<p>
<i>Haskell</i> también cuenta con un administrador de paquetes <i>Cabal</i>,
mediante el cual puedes instalar nuevas bibliotecas y programas. En
particular la utilizaremos más adelante para instalar <i>QuickCheck</i>.
</p>

<p>
Tanto <i>Haskell</i> y <i>Cabal</i> pueden ser instaladas con <code>ghcup</code>, que es un
instalador para éstos y más programas en torno a <i>Haskell</i>, y para
cualquier sistema basado en <i>Unix</i>, y los sistemas operativos <i>Windows</i>
y <i>MacOS</i>.
</p>

<p>
Las instrucciones específicas de cada sistema vienen en la
siguiente página:
</p>

<p>
<a href="https://www.haskell.org/ghcup/install/#installation">https://www.haskell.org/ghcup/install/#installation</a>
</p>
</div>


<div id="outline-container-orgfc79059" class="outline-4">
<h4 id="orgfc79059">Requerimientos</h4>
<div class="outline-text-4" id="text-orgfc79059">
<ul class="org-ul">
<li><p>
Debian &gt;= 12:
</p>

<div class="org-src-container">
<pre class="src src-shell">build-essential curl libffi-dev libffi8 libgmp-dev libgmp10 libncurses-dev libncurses5 libtinfo5
</pre>
</div></li>

<li><p>
Ubuntu &gt;= 23:
</p>

<div class="org-src-container">
<pre class="src src-shell">build-essential curl libffi-dev libffi8ubuntu1 libgmp-dev libgmp10 libncurses-dev
</pre>
</div></li>

<li><p>
Fedora:
</p>

<div class="org-src-container">
<pre class="src src-shell">gcc gcc-c++ gmp gmp-devel make ncurses ncurses-compat-libs xz perl
</pre>
</div></li>

<li><p>
Linux:
</p>

<p>
Investiguen según su distribución cómo instalar los siguientes paquetes:
</p>

<div class="org-src-container">
<pre class="src src-shell">curl g++ gcc gmp make ncurses realpath xz-utils
</pre>
</div></li>

<li><p>
Mac M1:
</p>

<p>
En los sistemas operativos <i>OS X</i> los programas requeridos se
configuran al instalar <code>ghcup</code>, posiblemente tengan que ejecutar
el comando otra vez.
</p>

<p>
En computadoras con <i>M1</i>, deben investiguen cómo instalar <code>llvm</code> con
<code>hombrew</code> y cómo exponerlo en el <code>PATH</code>.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orga7675e9" class="outline-4">
<h4 id="orga7675e9">GHCup</h4>
<div class="outline-text-4" id="text-orga7675e9">
<p>
El comando que debe utilizarse para instalarlo en <i>Linux</i>, <i>macOS</i>,
<i>FreeBSD</i> o <i>WSL2</i> es el siguiente:
</p>

<div class="org-src-container">
<pre class="src src-shell">curl --proto <span style="font-style: italic;">'=https'</span> --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
</pre>
</div>

<p>
(al 29 de enero de 2024, revisen la página si es que ésto cambia).
</p>

<p>
Al terminar la instalación reinicien su <code>shell</code> y el comando <code>ghcup
    tui</code> les abrirá una interfaz de terminal por la cual podrán navegar
por las distintas versiones de <i>GHC</i> y <i>Cabal</i>, sólo asegúrense de
usar las versiones de ambas herramientas respectivamente.
</p>
</div>
</div>
</div>

<div id="outline-container-org574dcd9" class="outline-3">
<h3 id="org574dcd9">QuickCheck y Happy</h3>
<div class="outline-text-3" id="text-org574dcd9">
<p>
Éstas son bibliotecas externas de <i>Haskell</i> por lo que es necesario
instalarlas con cabal.
</p>

<ul class="org-ul">
<li><p>
QuickCheck:
</p>

<div class="org-src-container">
<pre class="src src-bash">cabal install --lib QuickCheck
</pre>
</div></li>

<li><p>
Happy:
</p>

<div class="org-src-container">
<pre class="src src-bash">cabal install happy
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org6b1ef46" class="outline-3">
<h3 id="org6b1ef46">Introducción</h3>
<div class="outline-text-3" id="text-org6b1ef46">
<p>
La extensión comúnmente usada para los archivos es <code>.hs</code>
</p>
</div>

<div id="outline-container-org48e9a7d" class="outline-4">
<h4 id="org48e9a7d">Variables y tipos primitivos</h4>
<div class="outline-text-4" id="text-org48e9a7d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Tipo</th>
<th scope="col" class="org-left">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Int</td>
<td class="org-left">&#x2026;,-2,-1,0,1,2,&#x2026;</td>
</tr>

<tr>
<td class="org-left">Float, Double</td>
<td class="org-left">1.0,-1.25,2.5,&#x2026;</td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">True, False</td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-left">'a','b','c','\n',&#x2026;</td>
</tr>

<tr>
<td class="org-left">Integer</td>
<td class="org-left">&#x2026;,-1,0,1,2,3,&#x2026;</td>
</tr>
</tbody>
</table>

<p>
La creación de variables se puede hacer de la siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">x :: Int
x = 5

x' :: Float
x' = 10.42

y :: Double
y = 10.4283762683

z :: Bool
z = False

c :: Char
c = 'a'
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org08ffc1e"></a>Inmutabilidad<br />
<div class="outline-text-5" id="text-org08ffc1e">
<p>
En <i>Haskell</i> todas las variables son inmutables, es decir, una vez
que se definen, ya no pueden cambiar su valor.
</p>

<p>
Por ejemplo, el siguiente código nos arrojará un error:
</p>

<div class="org-src-container">
<pre class="src src-haskell">num :: Int
num = 1

num :: Int
num = 2
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org392cbdb" class="outline-4">
<h4 id="org392cbdb">Funciones</h4>
<div class="outline-text-4" id="text-org392cbdb">
<p>
Las funciones en <i>Haskell</i> juegan un papel esencial (claro, por eso
es un lenguaje de programación funcional).
</p>

<p>
En matemáticas, una función es una relación de elementos de un
conjunto \(A\) a elementos de un conjunto \(B\), donde un elemento de
\(A\) se "mapea" con un único elemento del conjunto \(B\).
</p>

<p>
Considera una función que eleva al cuadrado un número entero, su
dominio y codominio se denotaría como sigue:
</p>

<p>
\(f:\mathbb{Z}\to\mathbb{Z}\)
</p>

<p>
Se define la función:
</p>

<p>
\(f(x)=x^2\)
</p>

<p>
Y para evaluar la función, sustituyes los parámetros de la función
por un valor:
</p>

<p>
\(f(2)=2^2=4\)
</p>

<p>
\(f(3)=3^2=9\)
</p>

<p>
Análogamente, el tipo de esta función se denotaría como:
</p>

<div class="org-src-container">
<pre class="src src-haskell">f :: Int -&gt; Int
f x = x ^ 2
</pre>
</div>

<p>
Y para evaluar una función:
</p>

<div class="org-src-container">
<pre class="src src-haskell">resultado1 :: Int
resultado1 = f 2

resultado2 :: Int
resultado2 = f 3
</pre>
</div>

<p>
Para abrir el intérprete de <i>Haskell</i>, lo puédes abrir con
<code>ghci</code>. Para cargar un archivo dentro del intérprete, lo puedes
hacer con el comando <code>:l ruta/del/archivo.hs</code>
</p>

<p>
Y puedes evaluar las funciones o variables que definiste.
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; f 12
144
ghci&gt; f 9
81
ghci&gt; resultado1
4
ghci&gt; resultado2
9
</pre>
</div>

<p>
Sin embargo, cabe mencionar que la lógica para funciones
multivariadas cambia, al menos con los tipos.
</p>

<p>
Si ahora queremos hacer una función que recibe dos enteros y
devuelve otro entero (la suma de ambos), lo haríamos de la
siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">suma :: Int -&gt; Int -&gt; Int
suma x y = x + y
</pre>
</div>

<p>
Y para una función de 3 parámetros:
</p>

<div class="org-src-container">
<pre class="src src-haskell">suma3 :: Int -&gt; Int -&gt; Int -&gt; Int
suma3 x y z = x + y + z
</pre>
</div>
</div>
</div>

<div id="outline-container-orga5cc64f" class="outline-4">
<h4 id="orga5cc64f">Operadores</h4>
<div class="outline-text-4" id="text-orga5cc64f">
<p>
Aritméticas:
</p>

<ul class="org-ul">
<li>Suma: <code>+</code></li>
<li>Resta: <code>-</code></li>
<li>Multiplicación: <code>*</code></li>
<li>División (Real): <code>/</code></li>
<li>División (Entera): <code>div</code></li>
<li>Potencia: <code>^</code></li>
</ul>


<p>
Booleanas:
</p>

<ul class="org-ul">
<li>Negación: <code>not</code></li>
<li>Conjunción: <code>&amp;&amp;</code></li>
<li>Disyunción: <code>||</code></li>
</ul>


<p>
Comparación:
</p>

<ul class="org-ul">
<li>Igualdad: <code>==</code></li>
<li>Desigualdad: <code>/=</code></li>
<li>Menor que: <code>&lt;</code></li>
<li>Mayor que: <code>&gt;</code></li>
<li>Menor igual: <code>&lt;=</code></li>
<li>Mayor igual: <code>&gt;=</code></li>
</ul>
</div>
</div>

<div id="outline-container-org48d4ca5" class="outline-4">
<h4 id="org48d4ca5">Precedencia</h4>
<div class="outline-text-4" id="text-org48d4ca5">
<p>
Consideremos la función que dados dos números, suma los cuadrados
de ambos
</p>

<div class="org-src-container">
<pre class="src src-haskell">sumaCuadrados :: Int -&gt; Int -&gt; Int
sumaCuadrados x y = x^2 + y^2
</pre>
</div>

<p>
esta es una definición de función, cabe recordar que los nombres
de funciones y variables deben siempre iniciar con una letra
minúscula seguido de una serie de caracteres alfanuméricos.
</p>

<p>
Las funciones definidas de esta manera como ya vimos, las podemos
utilizar de la siguiente forma:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; suma_cuadrados 2 3
13
</pre>
</div>

<p>
Sin embargo, también es posible aplicar la función de manera
infija, escribiendo el nombre de la función entre dos acentos
graves <code>`</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 2 `suma_cuadrados` 3
13
ghci&gt; 5 `div` 2
2
</pre>
</div>

<p>
Pero haskell también nos deja crear nuestros propios operadores, y
su nombre puede ser cualquier combinación de los siguientes
símbolos:
</p>

<p>
<code>! # $ * + . / &lt; = &gt; ? \ ^ | : - ~ %</code>
</p>

<p>
Para denotar su tipo lo hacemos entre paréntesis:
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) :: Int -&gt; Int -&gt; Int
x &lt;+&lt; y = x^2 + y^2
</pre>
</div>

<p>
También es válido dar la definición de manera prefija escribiendo
el operador entre paréntesis.
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) :: Int -&gt; Int -&gt; Int
(&lt;+&lt;) x y = x^2 + y^2
</pre>
</div>

<p>
Y ya lo podemos utilizar como cualquier otro operador
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 2 &lt;+&lt; 3
13
</pre>
</div>

<p>
De la misma manera es posible utilizar cualquier operador de
manera prefija escribiendo el nombre del operador entre
paréntesis:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; (&lt;+&lt;) 2 3
13
ghci&gt; (+) 2 3
5
ghci&gt; (-) 5 2
3
</pre>
</div>

<p>
Al utilizar notación infija estamos eliminando el uso de
paréntesis
</p>

<div class="org-src-container">
<pre class="src src-haskell">(&lt;+&lt;) ((&lt;+&lt;) 2 3) 4
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">(2 &lt;+&lt; 3) &lt;+&lt; 4
2 &lt;+&lt; 3 &lt;+&lt; 4 -- Por defecto los operadores asocian a la izquierda
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">5/2+3*2/3*(231)
</pre>
</div>

<p>
Sin embargo al combinarlo con otros operadores, posiblemente
queramos que asocie de una forma distinta, y esto lo podemos hacer
con las palabras reservadas <code>infixl</code> e <code>infixr</code>, por ejemplo, la
asociatividas y precedencia de las operaciones aritméticas básicas
se muestra como sigue:
</p>

<div class="org-src-container">
<pre class="src src-haskell">infixl 6 +, -
infixl 7 *, /
</pre>
</div>

<p>
Y si quisiéramos que el operador <code>&lt;+&lt;</code> tuviera la misma precedencia
que la multiplicación y la división, lo tendríamos que definir
como sigue:
</p>

<div class="org-src-container">
<pre class="src src-haskell">infixl 7 &lt;+&lt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; 5 * 2 &lt;+&lt; 3 - 1
108
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb7d69b7" class="outline-4">
<h4 id="orgb7d69b7">Funciones anónimas</h4>
<div class="outline-text-4" id="text-orgb7d69b7">
<p>
¿Y si necesitamos hacer una función auxiliar que nada más usaré
una vez, vale la pena definirla si quiera?
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; (\x -&gt; x + 1) 4
5
ghci&gt; (\x y -&gt; x + y) 5 4
9
ghci&gt; (\x y z -&gt; x * y - z) 5 4 3
17
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1c07ad2" class="outline-3">
<h3 id="org1c07ad2">Listas, definiciones de tipos de dato y coincidencia de patrones</h3>
<div class="outline-text-3" id="text-org1c07ad2">
<p>
¿Recuerdan la definición inductiva de listas?
</p>

<p>
Listas con elementos de un tipo \(A\):
</p>

<ul class="org-ul">
<li>La lista vacía \([]\), es una lista con elementos de tipo \(A\).</li>

<li>Si \(x\) (cabeza) es un elemento de tipo \(A\) y \(xs\) una lista con
elementos de tipo \(A\), entonces \(x:xs\) es una lista de elementos
de tipo \(A\).</li>

<li>Son todas.</li>
</ul>


<p>
En <i>Haskell</i> también existen las listas bajo la misma semántica de
la definición inductiva.
</p>

<p>
Primero, podemos definir nuestros propios tipos de dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Color = Rojo | Verde | Azul
</pre>
</div>

<p>
<code>Rojo</code>, <code>Verde</code> y <code>Azul</code> son constructores
</p>

<p>
Funcionan similar a una enumeración en java.
</p>

<div class="org-src-container">
<pre class="src src-haskell">favorito :: Color
favorito = Verde
</pre>
</div>

<p>
Estas definiciones de tipos de dato pueden contener otros tipos,
por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Figura = Cuadrado Double
            | Rectangulo Double Double
            | Circulo Double
</pre>
</div>

<p>
<code>Cuadrado</code>, <code>Rectangulo</code> y <code>Circulo</code> son los constructores
</p>

<div class="org-src-container">
<pre class="src src-haskell">cuadrado :: Figura
cuadrado = Cuadrado 4.2

rectangulo :: Figura
rectangulo = Rectangulo 1.2 5.5

circulo :: Figura
circulo = Circulo 2.3
</pre>
</div>

<p>
¿Que pasa si un constructor tiene muchos tipos?
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Alumno = Alumno String String Double Int
</pre>
</div>

<p>
Podemos usar la sintaxis <i>record</i>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Alumno = Alumno { nombre :: String
                     , noCuenta :: String
                     , calif :: Double
                     , asistencias :: Int}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">limon :: Alumno
limon = Alumno { noCuenta = "123456789"
              , calif = 4.8
              , nombre = "Erik Rangel Limón"
              , asistencias = 2 }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; noCuenta erik
"123456789"
</pre>
</div>

<p>
Las definiciones de tipos de dato también pueden utilizar
variables de tipo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Talvez a = Nada | Solo a
</pre>
</div>

<p>
Los tipos de dato también pueden ser definiciones inductivas; por
ejemplo, los números naturales
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Nat = Zero
         | Suc Nat
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">cero :: Nat
cero = Zero

tres :: Nat
tres = Suc (Suc (Suc Zero))

cuatro :: Nat
cuatro = Suc tres
</pre>
</div>

<p>
Ahora, por fin, con las listas, ¿cómo seguimos con la definición?
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Lista a = Vacia -- La lista vacia es una lista de elementos de
                     -- tipo a
             | Cons a (Lista a) -- Un elemento concatenado con otra
                                -- lista de elementos de tipo a es
                                -- una lista con elementos de tipo a
</pre>
</div>

<p>
Afortunadamente <i>haskell</i> ya define este tipo de listas.
</p>

<div class="org-src-container">
<pre class="src src-haskell">data [] a = [] | a : ([] a)
</pre>
</div>

<p>
Por ejemplo, una lista con número enteros
</p>

<div class="org-src-container">
<pre class="src src-haskell">enteros :: [] Int
enteros = 1 : 2 : 3 : 4 : 5 : []
</pre>
</div>

<p>
Pero <i>haskell</i> ofrece una sintaxis más corta para representar listas
(y el tipo de una lista):
</p>

<div class="org-src-container">
<pre class="src src-haskell">enteros2 :: [Double]
enteros2 = [1.24,5.2,7.5,9.3]
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org04b2ee1"></a>Tipos sinónimo<br />
<div class="outline-text-5" id="text-org04b2ee1">
<p>
Nosotros podemos hacer sinónimos de tipos de dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">type Calificacion = Double
type Clase = [Alumno]
type Paleta = [Color]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">alumnos1 :: Clase
alumnos1 = [erik, juan, alberto]
</pre>
</div>
</div>
</li>
<li><a id="orga07c65b"></a>Strings<br />
<div class="outline-text-5" id="text-orga07c65b">
<p>
Sí, sí existen cadenas en haskell, pero éstas se definen como un
sinónimo de tipo:
</p>

<div class="org-src-container">
<pre class="src src-haskell">type String = [Char]
</pre>
</div>

<p>
Y para escribir cadenas de texto, haskell nos da la posibilidad
de usar <code>""</code> para representarlas.
</p>

<p>
<b>No olviden que las comillas simples <code>''</code> denotan caracteres</b>
</p>
</div>
</li>
</ul>

<div id="outline-container-org125bab1" class="outline-4">
<h4 id="org125bab1">Condicionales</h4>
<div class="outline-text-4" id="text-org125bab1">
<p>
Como en cualquier lenguaje de programación, tenemos expresiones
condicionales para manejar casos en los que se cumpla una
propiedad:
</p>

<p>
La sintaxis que tiene es la siguiente:
</p>

<p>
<code>if &lt;expresión booleana&gt; then &lt;expr de tipo A&gt; else &lt;expr de tipo A&gt;</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 4 &lt; 5 then "Primer caso" else "Segundo caso"
"Primer caso"  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 4 &lt; 3 then "Primer caso" else "Segundo caso"
"Segundo caso"
</pre>
</div>

<p>
Es importante que los resultados tanto del <code>then</code> como del <code>else</code> sean
del mismo tipo, si no, nos va a dar error:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; if 3 &lt; 4 then "Primer caso" else 2.5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">mimax :: Int -&gt; Int -&gt; Int
mimax n m = if n &gt; m then n else m
</pre>
</div>

<p>
La otra opción que tenemos para manejar casos es con guardias, y
éstas son exclusivas cuando se definen funciones.
</p>

<div class="org-src-container">
<pre class="src src-haskell">compara :: Int -&gt; Int -&gt; String
compara n m | n &lt; m = "El primero es menor que el segundo"
            | n == m = "Son iguales"
            | otherwise = "El primero es mayor que el segundo"
</pre>
</div>

<p>
Estas suelen reducir la sintaxis cuando son más las condiciones
que se deben revisar, sin embargo, debes cerciorarte de ser
completo con tus condiciones, es decir, que al menos una condición
se cumpla.
</p>

<p>
Para asegurar esto siempre es recomendable usar poner un caso para
cuando ninguna de las anteriores se haya cumplido.
</p>

<div class="org-src-container">
<pre class="src src-haskell">compara2 :: Int -&gt; Int -&gt; String
compara2 n m | n &lt; m = "El primero es menor que el segundo"
             | n == m = "Son iguales"
             | otherwise = "El primero es mayor que el segundo"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb7bb67" class="outline-4">
<h4 id="orgbb7bb67">Coincidencia de patrones</h4>
<div class="outline-text-4" id="text-orgbb7bb67">
<p>
Éste se le conoce en inglés como <i>pattern matching</i> y en español
muchas veces lo encontrarán como <i>caza de patrones</i>.
</p>

<p>
¿Cómo podemos utilizar funciones con éstos tipos de dato?
</p>

<div class="org-src-container">
<pre class="src src-haskell">describe :: Color -&gt; String
describe color = case color of
                   Rojo -&gt; "El color es rojo"
                   Verde -&gt; "El color es verde"
                   Azul -&gt; "El color es azul"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">describe2 :: Color -&gt; String
describe2 Rojo = "El color es rojo"
describe2 Verde = "El color es verde"
describe2 Azul = "El color es azul"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">predecesor :: Nat -&gt; Nat
predecesor Zero = Zero
predecesor (Suc n) = n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">ceroUno :: Nat -&gt; Nat
ceroUno Zero = Suc Zero
ceroUno n = n
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">esZero :: Nat -&gt; Bool
esZero Zero = True
esZero _ = False
</pre>
</div>

<p>
¿Ahora, cómo hacemos coincidencia de patrones con listas?
</p>

<div class="org-src-container">
<pre class="src src-haskell">alMenosUno :: [a] -&gt; Bool
alMenosUno [] = False
alMenosUno _ = True
</pre>
</div>

<p>
Si queremos obtener la cabeza de una lista:
</p>

<div class="org-src-container">
<pre class="src src-haskell">cabeza :: [a] -&gt; a
cabeza (x:xs) = x
</pre>
</div>

<p>
Si queremos obtener la cola de una lista:
</p>

<div class="org-src-container">
<pre class="src src-haskell">cola :: [a] -&gt; [a]
cola (x:xs) = xs
</pre>
</div>

<p>
Suma en naturales:
</p>

<p>
\(+(0,x)=x\)
</p>

<p>
\(+(s(n), m)=s(n+m)\)
</p>

<div class="org-src-container">
<pre class="src src-haskell">sumaNats :: Nat -&gt; Nat -&gt; Nat
sumaNats Zero m = m
sumaNats (Suc n) m = Suc (sumaNats n m)
</pre>
</div>

<p>
Niveles en un árbol:
</p>

<p>
Consideremos la definición de árboles binarios que viene en su
primera práctica:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Bin a = Vacio
           | Nodo a (Bin a) (Bin a) deriving Show
</pre>
</div>

<p>
Ahora queremos una función que nos regrese el número de hojas que hay en un árbol.
</p>

<p>
Una hoja es un árbol cuyos hijos izquierdo y derecho son vacíos.
</p>

<div class="org-src-container">
<pre class="src src-haskell">hojas :: Bin a -&gt; Int
hojas Vacio = 0
hojas (Nodo a Vacio Vacio) = 1
hojas (Nodo a l r) = hojas l + hojas r
</pre>
</div>

<p>
El nivel de un árbol:
</p>

<div class="org-src-container">
<pre class="src src-haskell">nivel :: Bin a -&gt; Int
nivel Vacio = -1
nivel (Nodo a l r) = 1 + max (nivel l) (nivel r)
</pre>
</div>

<p>
También podemos hacer coincidencia de patrones con la sintaxis
<i>record</i> de los tipos de dato.
</p>

<p>
Recordemos la definición que teníamos para el tipo de dato alumno:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Alumno = Alumno { nombre :: String
                     , noCuenta :: String
                     , calif :: Double
                     , asistencias :: Int}
</pre>
</div>

<p>
Una forma de hacerlo sería la siguiente:
</p>

<div class="org-src-container">
<pre class="src src-haskell">recordAlumno (Alumno nombre noCuenta calif asistencias) = ...
</pre>
</div>

<p>
Los parámetros del constructor se deben utilizar en el mismo orden
en el que se definió el tipo de dato.
</p>

<p>
¿Y si no necesitamos todos los datos?
</p>

<p>
Por ejemplo, a los alumnos se les dará un puntaje extra por las
veces que asistieron en un total de 10 clases, y queremos calcular
su calificación final.
</p>

<div class="org-src-container">
<pre class="src src-haskell">califFinal (Alumno _ _ calif asistencias) = calif + fromIntegral asistencias / 10
</pre>
</div>

<p>
Podemos usar comodines, o bien también podemos utilizar la
siguiente sintaxis:
</p>

<div class="org-src-container">
<pre class="src src-haskell">califFinal1 Alumno{calif=c,asistencias=a} = c + fromIntegral a / 10
</pre>
</div>

<p>
Usando esta sintaxis no es necesario poner todas los parámetros y
ponerlos en cualquier orden.
</p>

<p>
Supongamos el siguiente tipo de dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Escuela = Estudiante { nombre :: String
                          , noCuenta :: String
                          , calif :: Double
                          , asistencias :: Int}
             | Profesor { nombre :: String
                        , noTrabajador :: String}
</pre>
</div>

<p>
Si necesitamos una función que nos diga si un elemento es profesor
o alumno sería como la siguiente:
</p>

<div class="org-src-container">
<pre class="src src-haskell">describe Estudiante{} = "Es un alumno"
describe Profesor{} = "Es un profesor"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb2f420" class="outline-4">
<h4 id="orgbb2f420">Funciones de orden superior</h4>
<div class="outline-text-4" id="text-orgbb2f420">
<p>
Una función de orden superior, es una función que puede recibir
como parámetro otra función.
</p>

<p>
Por ejemplo, las derivadas e integrales son funciones que reciben
como parámetro otra función.
</p>

<p>
En caso de <i>haskell</i> no vamos a derivar ni nada, pero utilizaremos
funciones de orden superior.
</p>

<p>
Por ejemplo, ¿qué pasa si queremos sumar uno a todos los números
de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">aumenta :: [Int] -&gt; [Int]
aumenta [] = []
aumenta (x:xs) = x+1 : aumenta xs
</pre>
</div>

<p>
Y ahora, ¿si lo que queremos es elevar al cuadrado todos los
números de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">eleva :: [Int] -&gt; [Int]
eleva [] = []
eleva (x:xs) = x^2 : eleva xs
</pre>
</div>

<p>
Las dos funciones son muy similares, ¿es posible generalizarlas?
</p>

<p>
Sí, con funciones de orden superior:
</p>

<div class="org-src-container">
<pre class="src src-haskell">mimap :: (a -&gt; b) -&gt; [a] -&gt; [b]
mimap f [] = []
mimap f (x:xs) = f x : mimap f xs
</pre>
</div>

<p>
Entonces, ¿cómo elevamos al cuadrado todos los elementos de una lista?
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; mimap (\x -&gt; x ^ 2) [1,2,3,4,5]
[1,4,9,16,25]
ghci&gt; mimap (\x -&gt; x + 1) [1,2,3,4,5]
[2,3,4,5,6]
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org325903c" class="outline-2">
<h2 id="org325903c">Clases</h2>
<div class="outline-text-2" id="text-org325903c">
<p>
¿Qué tipo tiene el operador de la suma en <i>Haskell</i>?
</p>

<div class="org-src-container">
<pre class="src src-haskell">(+) :: Num a =&gt; a -&gt; a -&gt; a
</pre>
</div>

<p>
¿Ésto que quiere decir?
</p>

<p>
<code>Num a</code> hace referencia a que <code>a</code>, sea cual sea su tipo debe ser un
número, posteriromente nos dice que recibe dos cosas de tipo <code>a</code> y nos
regresa algo de tipo <code>a</code>.
</p>

<p>
Las clases funcionan de manera similar que las interfaces en un
lenguaje de programación orientado a objetos; éstos sólo definen qué
comportamiento debería tener si éste pertenece a la interfaz, sin
embargo no se especifica el cómo de este comportamiento.
</p>

<p>
De la misma forma podemos hacerlo en <i>Haskell</i> por medio de clases, en
donde sólo indicaremos las firmas de las funciones o variables que
la conforman.
</p>

<p>
En el preludio de <i>Haskell</i>, <code>Num</code> se define como sigue:
</p>

<div class="org-src-container">
<pre class="src src-haskell">class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer -&gt; a
</pre>
</div>

<p>
¿Qué tipos de dato pertenecen a la clase <code>Num</code>?
</p>

<p>
Con el comando <code>:i</code> haskell les puede mostrar información general
sobre cualquier expresión en el lenguaje.
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; :i Num
type Num :: * -&gt; Constraint
class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer -&gt; a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
        -- Defined in ‘GHC.Num’
instance Num Double -- Defined in ‘GHC.Float’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
</pre>
</div>

<p>
Lo que nos importa es lo último, donde nos menciona que los tipos de
dato <code>Int</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code> y <code>Word</code> son instancias de la clase
<code>Num</code>, y por tanto podemos utilizar cualquier función definida en esta
clase para estos tipos de dato.
</p>

<p>
¿Y cómo hacemos que un tipo de dato sea <code>Num</code>?
</p>

<p>
Por ejemplo, haremos los números complejos.
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Complex = Complex Double Double
</pre>
</div>

<p>
Anteriormente, vimos esto:
</p>

<div class="org-src-container">
<pre class="src src-haskell">{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
</pre>
</div>

<p>
Por lo general cuando busquemos información sobre una clase
predefinida en <i>Haskell</i> nos encontraremos con esta instrucción del
compilador.
</p>

<p>
Ésta nos indica la definición mínima para que un tipo de dato tenga
una definición completa para que ésta sea instancia de la clase.
</p>

<p>
En particular la de la clase num nos dice que se deben definir:
</p>

<ul class="org-ul">
<li>suma (+)</li>

<li>multiplicación (*)</li>

<li>valor absoluto (abs)</li>

<li>signo de un número (signum)</li>

<li>Conversión de entero al tipo de dato en cuestión (fromInteger)</li>

<li>Negación de un número (negate) o la resta (-) (Es decir, basta con que definamos alguna de las dos)</li>
</ul>


<div class="org-src-container">
<pre class="src src-haskell">instance Num Complex where
  (Complex a b) + (Complex c d) = Complex (a + c) (b + d)
  (Complex a b) * (Complex c d) = Complex (a * c - b * d) (a * d + b * c)
  abs (Complex x y) = Complex (sqrt $ x^2 + y^2) 0
  signum x = case abs x of
               Complex a _ -&gt; x * Complex (1 / a) 0
  fromInteger int = Complex (fromInteger int) 0
  negate (Complex a b) = Complex (negate a) (negate b)
</pre>
</div>

<p>
Con esto podemos ya operar con números complejos usando los
operadores de siempre
</p>

<div class="org-src-container">
<pre class="src src-bash">ghci&gt; Complex 0 1 * Complex 0 1

&lt;interactive&gt;:53:1: error:
    &#8226; No instance for (Show Complex) arising from a use of &#8216;print&#8217;
    &#8226; In a stmt of an interactive GHCi command: print it
</pre>
</div>

<p>
¿Qué significa ésto?
</p>

<p>
Aún no le hemos especificado a <i>haskell</i> cómo se deben imprimir los
números complejos.
</p>

<p>
Una forma de solucionar esto, es añadiendo lo siguiente al tipo de
dato:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Complex = Complex Double Double deriving Show
</pre>
</div>

<p>
Con esto le indicamos a <i>haskell</i> que queremos imprimir los números
complejos como nosotros lo escribiríamos en el intérprete, es decir,
usando sus constructores.
</p>

<div class="org-src-container">
<pre class="src src-bash">ghci&gt; Complex 0 1 * Complex 0 1
<span style="font-weight: bold;">Complex</span> (-1.0) 0.0
</pre>
</div>

<p>
Pero, ¿y si queremos cambiar la forma en la que éste tipo de dato se
imprime?
</p>

<p>
Bueno <code>Show</code> también es una clase
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci&gt; :i Show
type Show :: * -&gt; Constraint
class Show a where
  showsPrec :: Int -&gt; a -&gt; ShowS
  show :: a -&gt; String
  showList :: [a] -&gt; ShowS
  {-# MINIMAL showsPrec | show #-}
        -- Defined in ‘GHC.Show’
  ...
</pre>
</div>

<p>
Y nos dice que una definición completa será si definimos la función
<code>show</code> o <code>showsPrec</code>.
</p>

<p>
<code>show</code> se usa para indicar directamente cómo queremos que se imprima.
</p>

<p>
<code>showsPrec</code> es si en nuestros constructores queremos que se impriman
con operadores indicando la precedencia que tiene cada uno de ellos.
</p>

<p>
Para éste curso nos basta con implementar <code>show</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">instance Show Complex where
  show (Complex x y)
    | x == 0 = if y == 0 then show 0 else show y ++ "i"
    | signum y == 1 = show x ++ " + " ++ show y ++ "i"
    | signum y == 0 = show x
    | otherwise = show x ++ " - " ++ show (negate y) ++ "i"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">ghci&gt; Complex 0 1 * Complex 0 1
-1.0
ghci&gt; Complex 0 1 * Complex 1 1
-1.0 + 1.0i
ghci&gt; Complex 1 (-12)
1.0 - 12.0i
ghci&gt; Complex 1 1 + Complex 1 1
2.0 + 2.0i
ghci&gt; Complex 1 1 * Complex 1 1
2.0i
</pre>
</div>
</div>
</div>

<div id="outline-container-org148891a" class="outline-2">
<h2 id="org148891a">Práctica 1</h2>
<div class="outline-text-2" id="text-org148891a">
<p>
<a href="./practica1/practica1.html">Práctica 1</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Erik Rangel Limón</p>
<p class="date">Created: 2024-08-13 Tue 14:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
