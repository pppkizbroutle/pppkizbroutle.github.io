<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-19 Mon 11:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Compiladores</title>
<meta name="author" content="Erik Rangel Limón" />
<meta name="generator" content="Org Mode" />
<style type="text/css">/* Base */html,body {    background-color: #222;    min-height: 100%;    line-height: 1.5;}body {    color: #fafafa;    font-family: "Courier New";}::selection {    background-color:  #2ecc40;    color: white;}/* Responsive content positioning */@media only screen and (min-width: 1020px) /* Large screens */{    body{        padding: 10vh 25vw;    }}@media only screen and (max-width: 1020px) and (min-width: 750px) /* Small screens */{    body{        padding: 5vh 10vw;    }}@media only screen and (max-width: 750px) /* Small screens */{    body{        padding: 2vh 5vw;    }}/* Headers */h1{font-size: 2.5rem;}h2{font-size: 1.7rem;}h1 > .subtitle, h3, h4, h5, h6{font-size: 1.3rem;}.title{    margin-bottom: 2.5rem;}/* Padding & Margin */* {margin: 0; padding: 0;}pre, blockquote, ul, ol, p, table{    margin: 1rem 0;}h1, h2{margin-top: 2rem; line-height: 2rem;}h3, h4, h5, h6{margin-top: 1rem;}/* Links  */a, a:visited {    color: #01ff70;    text-decoration: underline;}a:hover, a:focus, a:active {    color: #2ecc40;}/* Code */pre {    font-family: "Courier New";    padding: .5rem;    background-color: #333;    padding: 0.5rem;    border-radius: 0.2rem;    font-size: 0.9rem;    color: #EEE;    overflow-x: auto;}.org-keyword{    color: #01ff70;}.org-rainbow-delimiters-depth-1{    color: #2ecc40;}.org-rainbow-delimiters-depth-2{    color: #01ff70;}/* Blockquotes */blockquote {    border-left: 3px solid #01ff70;    padding-left: 1rem;}li{    list-style-position: inside;}/* Tags */.tag{    margin-top: 0.5rem;    display: block;    color: white;    font-size: var(--font-size-xsmall);}.tag > span{		font-weight: 400;    font-size: 0.8rem;    background-color: #444;    text-transform: uppercase;    border-radius: 2px;    width: fit-content;    height: auto;    padding: 1px 5px;}/* Keywords */.todo{    color: #2ecc40;}.done{    color: #444;}/* Overflows */.outline-text-2, .outline-text-3, .outline-text-4{	  max-width: 100%;	  overflow-x: auto;}/* Table */tr:nth-child(even) {    background-color: #333;}th, td{    padding: 0.5rem;    text-align: center;}.underline{    text-decoration: underline;}img{    max-width: 100%;    height: auto;}</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Compiladores</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org59e1cd2">Rubros</a></li>
<li><a href="#org1fe9b02">Notas</a>
<ul>
<li><a href="#orge4dd3c9">Temario ( 15 / 08 / 23 )</a></li>
<li><a href="#org5ce506f">Autómatas (repaso)</a></li>
<li><a href="#org204d687">16 / 08 / 23</a>
<ul>
<li><a href="#org187a4d1">Compilador</a></li>
<li><a href="#org16b2d88">Jerarquía de Chomsky</a></li>
<li><a href="#orgbc2057a">Autómatas finitos y expresiones regulares</a></li>
<li><a href="#org9a229cc">Técnicas de optimización</a></li>
<li><a href="#org8fe29d9">Otros avances</a></li>
<li><a href="#org5c434f5">Intérpretes</a></li>
<li><a href="#org72e1bb4">Ensambladores</a></li>
<li><a href="#orgce992d4">Enlazador</a></li>
<li><a href="#orge4f1594">Preprocesadores</a></li>
<li><a href="#org0218083">Editores</a></li>
<li><a href="#org8d67870">Depuradores</a></li>
<li><a href="#org26b3bf9">Perfiladores</a></li>
<li><a href="#org9d878de">Administradores de proyecto</a></li>
</ul>
</li>
<li><a href="#org59ee0e1">17 / 08 / 23</a>
<ul>
<li><a href="#org72f8381">Lenguajes Regulares</a></li>
<li><a href="#org710f666">Regex</a></li>
</ul>
</li>
<li><a href="#org7cd0a27">21 / 08 / 23</a>
<ul>
<li><a href="#org68c653e">Introducción</a></li>
</ul>
</li>
<li><a href="#org3b21855">23 / 08 / 23</a>
<ul>
<li><a href="#orgb541dbb">Estructuras de datos principales en un compilador</a></li>
</ul>
</li>
<li><a href="#orgf26b7e2">28 / 08 / 23</a>
<ul>
<li><a href="#orgd584b89">Compiladores</a></li>
</ul>
</li>
<li><a href="#org1b57557">29 / 08 / 23</a>
<ul>
<li><a href="#org1f4a898">Gramáticas (libres del contexto)</a></li>
</ul>
</li>
<li><a href="#org3870cdb">30 / 08 / 23</a>
<ul>
<li><a href="#org0eae446">Teoría de Lenguajes de Programación y Teoría de Compiladores</a></li>
<li><a href="#orgf603ff1">Manejo de errores</a></li>
<li><a href="#org52000fa">Autohosting y bootstraping</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org59e1cd2" class="outline-2">
<h2 id="org59e1cd2">Rubros</h2>
<div class="outline-text-2" id="text-org59e1cd2">
<ul class="org-ul">
<li>Prácticas 20%</li>
<li>Proyecto final 30%</li>
<li>Exámenes parciales 30%</li>
<li>Exámenes semanales 20%</li>
</ul>
</div>
</div>

<div id="outline-container-org1fe9b02" class="outline-2">
<h2 id="org1fe9b02">Notas</h2>
<div class="outline-text-2" id="text-org1fe9b02">
</div>
<div id="outline-container-orge4dd3c9" class="outline-3">
<h3 id="orge4dd3c9">Temario ( 15 / 08 / 23 )</h3>
<div class="outline-text-3" id="text-orge4dd3c9">
<ol class="org-ol">
<li>Introducción</li>

<li>Análisis léxico y sintáctico</li>

<li>Análisis sintáctico descendente</li>

<li>Análisis sintáctico ascendente</li>

<li>Análisis semántico</li>

<li>Ambientes de ejecución</li>

<li>Generación de código</li>
</ol>
</div>
</div>

<div id="outline-container-org5ce506f" class="outline-3">
<h3 id="org5ce506f">Autómatas (repaso)</h3>
<div class="outline-text-3" id="text-org5ce506f">
<ul class="org-ul">
<li>Lenguaje: Es un conjunto de cadenas sobre un alfabeto \(\Sigma\).

<ul class="org-ul">
<li>\(\Sigma = \{a,b\}\)</li>

<li>\(\mathcal{L}=\{ab,ba\}\)</li>

<li>\(\mathcal{L}=\textit{todos las cadenas que tienen al menos 2 a's}\)</li>
</ul></li>
</ul>


<p>
Existen varias categorías de los lenguajes
</p>

<ul class="org-ul">
<li>Lenguajes Regulares</li>

<li>Lenguajes Libres del Contexto</li>

<li>Lenguajes Dependientes del Contexto</li>
</ul>


<p>
Un lenguaje puede tener la cadena vacía.
</p>

<ul class="org-ul">
<li>\(\varepsilon\): La cadena vacía; una palabra sin ningún símbolo.</li>

<li>\(\emptyset\neq\{\varepsilon\}\)</li>
</ul>


<p>
Existen operaciones que se pueden hacer entre los lenguajes
</p>

<ul class="org-ul">
<li>Unión (\(\mathcal{L}\cup\mathcal{M}\)): Contiene todas las palabras
de \(\mathcal{L}\) y todas las palabras de \(\mathcal{M}\).</li>

<li>Concatenación (\(\mathcal{L}\mathcal{M}\)): Todas las posibles
concatenaciones de palabras de \(\mathcal{L}\) con \(\mathcal{M}\)</li>

<li>Cerradura de Kleene:
<ul class="org-ul">
<li>\(\mathcal{L}^n=\mathcal{L}\mathcal{L}\cdots\mathcal{L}\) (n veces)</li>
<li>\(\mathcal{L}^0=\{\varepsilon\}\)</li>
<li>\(\mathcal{L}^*=\{\mathcal{L}^n\ |\ n}\geq 0\}\)</li>
</ul></li>

<li>Cerradura positiva: \(\mathcal{L}^+=\{L^n\ |\ n>0\}\)</li>
</ul>
</div>
</div>

<div id="outline-container-org204d687" class="outline-3">
<h3 id="org204d687">16 / 08 / 23</h3>
<div class="outline-text-3" id="text-org204d687">
</div>
<div id="outline-container-org187a4d1" class="outline-4">
<h4 id="org187a4d1">Compilador</h4>
<div class="outline-text-4" id="text-org187a4d1">
<p>
Un compilador es un programa que traduce de un lenguaje a
otro. Toma como entrada un programa escrito en un lenguaje fuente
(.java, .c) y produce un programa equivalente escrito en un
lenguaje objetivo (.class, .out, .exe).
</p>

<ul class="org-ul">
<li>El lenguaje fuente es un lenguaje de alto nivel.</li>

<li>El lenguaje objetivo es código objeto (máquina)</li>
</ul>


<p>
<i>No tomar a la ligera la palabra programa pues no es para nada</i>
<i>sencillo. La mayoría de computólogos nunca han escrito un</i>
<i>compilador completo</i>.
</p>
</div>
</div>

<div id="outline-container-org16b2d88" class="outline-4">
<h4 id="org16b2d88">Jerarquía de Chomsky</h4>
<div class="outline-text-4" id="text-org16b2d88">
<ul class="org-ul">
<li>Los estudios de <i>Noam Chomsky</i> condujeron a la clasificación de
los lenguajes de acuerdo a la complejidad de sus gramáticas y la
potencia de los algoritmos necesarios para reconocerlas.</li>

<li>La jerarquía se compone de cuatro niveles de gramáticas,
denominadas tipo 0, tipo 1, tipo 2 y tipo 3, cada una de las
cuales es una especialización de la anterior.

<ul class="org-ul">
<li>Tipo 0: Lenguajes sin restricciones</li>

<li>Tipo 1: Lenguajes dependientes de Contexto</li>

<li>Tipo 2: Lenguajes Libres de Contexto</li>

<li>Tipo 3: Lenguajes Regulares</li>
</ul></li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org7a8c0eb"></a>Gramáticas libres de contexto<br />
<div class="outline-text-5" id="text-org7a8c0eb">
<ul class="org-ul">
<li>Las gramáticas de tipo 2, mejor conocidas como gramáticas
libres de contexto, han demostrado ser las más útiles para
especificar lenguajes de programación.</li>

<li>El problema de análisis sintáctico consiste en encontrar
algoritmos eficientes que reconozcan lenguajes libres de
contexto.</li>

<li>El estudio de este problema conduja al desarrollo de programas
que automatizan solución mediante los llamados compiladores de
compilador hoy llamados generadores de analizadores
sintácticos.</li>

<li>El más conocido de los programas es Yacc. Fue escrito por Steve
Johnson en 1975 para el sistema Unix.</li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgbc2057a" class="outline-4">
<h4 id="orgbc2057a">Autómatas finitos y expresiones regulares</h4>
<div class="outline-text-4" id="text-orgbc2057a">
<ul class="org-ul">
<li>Estas técnicas, corresponden a las gramáticas tipo 3 y se
encuentran relacionadas con las gramáticas libres de contexto.</li>

<li>Su estudio condujo a métodos simbólicos para expresar la
estructura de las palabras o tokens de un lenguaje de
programación.</li>

<li>Esto llevó al desarrollo de otra herramienta denominada
generador de analizadores léxicos, cuyo representante más
conocido es Lex.</li>
</ul>
</div>
</div>

<div id="outline-container-org9a229cc" class="outline-4">
<h4 id="org9a229cc">Técnicas de optimización</h4>
<div class="outline-text-4" id="text-org9a229cc">
<ul class="org-ul">
<li>Otro aspecto destacable en el área ha sido el desarrollo de
métodos para la generación de código objeto eficaz.</li>

<li>Estas técnicas suelen denominarse incorrectamente técnicas de
optimización, pero en realidad debería llamarse técnicas de
mejoramiento de código, pues casi nunca producen un código
objeto verdaderamente óptimo.</li>
</ul>
</div>
</div>

<div id="outline-container-org8fe29d9" class="outline-4">
<h4 id="org8fe29d9">Otros avances</h4>
<div class="outline-text-4" id="text-org8fe29d9">
<ul class="org-ul">
<li>Algoritmos para inferir y / o simplificar la información
contenida en un programa, por ejemplo el algoritmo de
unificación de tipos de <i>Hindley-Milner</i>.</li>

<li>Integración con los llamados entornos de desarrollo integrados.</li>
</ul>
</div>
</div>

<div id="outline-container-org5c434f5" class="outline-4">
<h4 id="org5c434f5">Intérpretes</h4>
<div class="outline-text-4" id="text-org5c434f5">
<ul class="org-ul">
<li>A diferencia de un compilador, un intérprete ejecuta un programa
fuente inmediatamente.</li>

<li>Cualquier lenguaje de programación se puede interpretar o
compilar, pero se puede preferir un intérprete a un compilador
dependiendo del lenguaje y del contexto.</li>

<li>Es un error hablar de un lenguaje compilado o lenguaje
interpretado pues existes lenguajes que tienen ambos tipos de
traductor.</li>

<li>Los compiladores comparten muchas de sus operaciones con los
intérpretes y existen incluso traductores híbridos.</li>
</ul>
</div>
</div>

<div id="outline-container-org72e1bb4" class="outline-4">
<h4 id="org72e1bb4">Ensambladores</h4>
<div class="outline-text-4" id="text-org72e1bb4">
<ul class="org-ul">
<li>Un ensamblador es un traductor para el lenguaje ensamblador.</li>

<li>Muchos compiladores generan lenguaje ensamblador como lenguaje
objetivo y por lo tanto depende de un ensamblador para terminar
la traducción a código objeto.</li>
</ul>
</div>
</div>

<div id="outline-container-orgce992d4" class="outline-4">
<h4 id="orgce992d4">Enlazador</h4>
<div class="outline-text-4" id="text-orgce992d4">
<ul class="org-ul">
<li>Es un programa que combina los códigos objeto generados por el
compilador o ensamblador así como otras piezas de código para
generar un archivo ejecutable.</li>
<li>En los códigos objeto, el enlazador busca y agrega todas las
bibliotecas necesarias para la ejecución del archivo.</li>
<li>Regulan el espacio de memoria que guardará el código de cada
módulo.</li>
<li>Fusiona dos o más programas de códigos separados y establece un
vínculo entre ellos.</li>
</ul>
</div>
</div>

<div id="outline-container-orge4f1594" class="outline-4">
<h4 id="orge4f1594">Preprocesadores</h4>
<div class="outline-text-4" id="text-orge4f1594">
<ul class="org-ul">
<li>Son programas separados que son invocados por el compilador
antes de que comience la traducción real.</li>
<li>Eliminan los comentarios, incluyen otros archivos y ejecutan
sustituciones de macros.</li>
<li>Pueden ser requeridos por el lenguaje (como en C) o pueden ser
agregados posteriormente para que proporcionen facilidades
adicionales.</li>
</ul>
</div>
</div>

<div id="outline-container-org0218083" class="outline-4">
<h4 id="org0218083">Editores</h4>
<div class="outline-text-4" id="text-org0218083">
<ul class="org-ul">
<li>Los compiladores aceptan programas fuente escritos usando
cualquier editor.</li>

<li>Recientemente los compiladores han sido integrados junto a
editores y otros programas en los IDEs de forma que puedan ser
orientados hacia el formato o estructura del lenguaje de
programación.</li>

<li>Se denominan basados en la estructura e icluyen alguna
operaciones de un compilador, de manera que, por eemplo, pueda
informarse a los programadores sobre los errores a medida que el
programa se vaya escribiendo.</li>
</ul>
</div>
</div>

<div id="outline-container-org8d67870" class="outline-4">
<h4 id="org8d67870">Depuradores</h4>
<div class="outline-text-4" id="text-org8d67870">
<ul class="org-ul">
<li>Son programas que se usan para determinar los errores de
ejecución en un programa.</li>

<li>La ejecución de un programa con un depurador se diferencia de la
ejeción directa en que el depurador mantiene al tanto de la
mayoría o la totalidad de la información sobre el código fuente,
tal como los números de línea y los nombres de variables y
funciones.</li>

<li>También puede determinar la ejecución en puntos previamente
especificados.</li>
</ul>
</div>
</div>

<div id="outline-container-org26b3bf9" class="outline-4">
<h4 id="org26b3bf9">Perfiladores</h4>
<div class="outline-text-4" id="text-org26b3bf9">
<ul class="org-ul">
<li>Un perfilador es un programa que recolecta estadísticas sobre el
comportamienbto de un programa objeto durante la ejecución.</li>

<li>Las estadísticas típicas que pueden ser de interés para los
programadores son el número de veces que se llama cada función y
el porcentaje de tiempo de ejecución que se ocupa en cada uno de
ellos.</li>
</ul>
</div>
</div>

<div id="outline-container-org9d878de" class="outline-4">
<h4 id="org9d878de">Administradores de proyecto</h4>
<div class="outline-text-4" id="text-org9d878de">
<ul class="org-ul">
<li>Los proyecto de software por lo general son tan grandes que
tienen que ser realizados por grupos de programadores en lugar
de por una sola persona.</li>

<li>En tales casos es importante que los archivos y éste es el
trabajo de un programa de administración de proyecto.</li>

<li>Por ejemplo, un administrador de proyecto debería coordinar la
combinación de diferentes versiones del mismo archivo producido
por programadores diferentes.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org59ee0e1" class="outline-3">
<h3 id="org59ee0e1">17 / 08 / 23</h3>
<div class="outline-text-3" id="text-org59ee0e1">
</div>
<div id="outline-container-org72f8381" class="outline-4">
<h4 id="org72f8381">Lenguajes Regulares</h4>
<div class="outline-text-4" id="text-org72f8381">
<p>
Un lenguaje \(\mathcal{L}\) bajo un alfabeto \(\Sigma\) es regular si
se puede generar a partir de lenguajes básicos (\(\{\varepsilon\}\),
\(\emptyset\), \(\{a\}\)).
</p>

<ul class="org-ul">
<li>\(\emptyset\) es regular</li>

<li>\(\{\varepsilon\}\) es regular</li>

<li>Si \(a\in\Sigma\), entonces \(\{a\}\) es un lenguaje regular.</li>

<li>Si \(\mathcal{L}\) es regular, entonces \(\mathcal{L}^*\) también es
regular.</li>

<li>Si \(\mathcal{L}\) y \(\mathcal{M}\) son lenguajes regulares,
entonces \(\mathcal{L}\cup\mathcal{M}\) y \(\mathcal{LM}\) son
regulares.</li>

<li>Son todas</li>
</ul>
</div>
</div>

<div id="outline-container-org710f666" class="outline-4">
<h4 id="org710f666">Regex</h4>
<div class="outline-text-4" id="text-org710f666">
<ul class="org-ul">
<li>\(\emptyset\) es un regex</li>

<li>\(\varepsilon\) es un regex</li>

<li>Si \(a\in\Sigma\), entonces \(a\) es un regex</li>

<li>Si \(\alpha\) es un regex, entonces \(\alpha^*\) es un regex</li>

<li>Si \(\alpha\), \(\beta\) son regex, entonces \(\alpha+\beta\) y
\(\alpha\beta\) son regex.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7cd0a27" class="outline-3">
<h3 id="org7cd0a27">21 / 08 / 23</h3>
<div class="outline-text-3" id="text-org7cd0a27">
</div>
<div id="outline-container-org68c653e" class="outline-4">
<h4 id="org68c653e">Introducción</h4>
<div class="outline-text-4" id="text-org68c653e">
<p>
Un compilador se compone internamente de varias etapas, o fases
que realizan distintas operaciones lógicas.
</p>

<p>
Es útil pensar en estas fases como piezas separadas aunque a
menudo se integren juntas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Código fuente</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Analizador léxico</td>
<td class="org-left">Detectar palabras</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Tokens</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Analizador sintáctico</td>
<td class="org-left">Analizar estructura</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Árbol de sintaxis abstracta</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Analizador semántico</td>
<td class="org-left">Analiza significado</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Árbol con anotaciones</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Optimizador de código fuente</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Código intermedio</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Generador de código</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Código objetivo</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Optimizador de código objetivo</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Código objetivo</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li><a id="org0394148"></a>Analizador léxico<br />
<div class="outline-text-5" id="text-org0394148">
<ul class="org-ul">
<li>En esta fase se ejecuta la lectura del programa fuente, el cuál
generalmente es dado en forma de cadena.</li>

<li>Se realiza lo que se conoce como análisis léxico es decir,
recolecta subcadenas en unidades significativas denominadas
lexemas o tokens las cuales son como las palabras de un
lenguaje natural, como el español.</li>

<li>De este modo, podemos pensar en un analizador léxico como un
programa que realiza una función similar al deletreo.</li>
</ul>
</div>
</li>

<li><a id="org8970fcc"></a>Analizador sintáctico<br />
<div class="outline-text-5" id="text-org8970fcc">
<ul class="org-ul">
<li>Recibe el código fuente en forma de tokens proveniente del
analizador léxico y realiza un análisis sintáctico que
determina la estructura del programa.</li>

<li>Determina los elementos estructurales del programa y sus
relaciones.</li>

<li>Los resultados del análisis sintáctico usualmente se
representan como árboles de análisis gramaticales o árboles de
sintaxis abstracta.</li>

<li>Un árbol de análisis gramatical es un auxiliar para visualizar
la sintaxis del programa o de un elemento de programa, pero no
es eficaz en su representación de dicha estructura.</li>

<li>Los analizadores sintácticos tienden a generar un árbol de
sintaxis abstracta (asa) en su lugar, el cual es una
condensación de la información contenida en un árbol de
análisis gramatical.</li>

<li>Se les llama abstractos porque representan una abstracción
adicional de los árboles de análisis gramatical.</li>
</ul>
</div>
</li>

<li><a id="orgbfd4a40"></a>Analizador semántico<br />
<div class="outline-text-5" id="text-orgbfd4a40">
<ul class="org-ul">
<li>La semántica de un programa es su <i>significado</i>, en oposición a
su sintaxis o estructura.</li>

<li>La semántica determina el comportamiento de un programa durante
ejecución, sin embargo, un compilador puede determinar otras
características a partir de lo escrito.</li>

<li>Se hace referencia a tales características como semántica
estática y el análisis de tal semántica es la tarea del
analizador semántico.</li>

<li>La semántica dinámica de un programa, es decir, aquellas
propiedades del programa que sólo pueden determinar al
ehjecutarlo, no se pueden determinar mediante un compilador
porque éste no ejecuta el programa.</li>

<li>Las características típicas de la semántica estática incluyen
las declaraciones y la verificación de tipos.</li>

<li>Las partes extra de la información (como los tipos de datos)
que se calculan mediante un analizador semántico se llaman
atributos y con frecuencia se agregan al árbol como anotaciones
(también se pueden introducir en la tabla de símbolos).</li>
</ul>
</div>
</li>

<li><a id="org71bb08c"></a>Optimizador de código fuente<br />
<div class="outline-text-5" id="text-org71bb08c">
<ul class="org-ul">
<li>Los compiladores a menudo incluyen varias etapas para el
mejoramiento, y optimización del código.</li>

<li>El punto más anticipado en el que la mayoría de las etapas de
optimización se pueden realizar es precisamente después del
análisis semántico, y puede haber posibilidades para el
mejoramiento del código que dependerán sólo del código fuente.</li>

<li>Se indica esta posibilidad al proporcionar esta operación como
una fase por separado en el proceso de compilación.</li>

<li>Los compiladores muestran una amplia variación no sólo en los
tipos de optimizaciones realizadas sino también en la
colocación de las fases de optimización.</li>

<li>Muchas optimizaciones se pueden efectuar sobre el <i>asa</i>, pero es
más fácil optimizar una forma que esté más cercana al código
ensamblador.</li>

<li>Existen variedades diferentes como es el código en tres
direcciones, denominado así porque contiene las direcciones de
a lo más tres localidades de memoria.</li>

<li>Al emplear el código en tres direcciones, nos podemos referir a
su salida como código intermedio.</li>

<li>Históricamente, el código intermedio ha hecho referencia a una
forma de representación de código intermedia entre el código
fuente y el código objeto tal como el código en tres
direcciones.</li>

<li>También puede referirse de manera general a <b>cualquier</b>
representación interna para el código fuente utilizado por el
compilador.</li>

<li>En este sentido, también se puede hacer referencia al <i>asa</i> como
un código intermedio, y efectivamente el optimizador de código
guente podría continuar el uso de esta representación en su
salida.</li>

<li>En ocasiones este sentido general se indica al hacer referencia
al código intermedio como <b>representación intermedia</b>, o <b>RI</b>.</li>
</ul>
</div>
</li>

<li><a id="org5adae6e"></a>Generador de código<br />
<div class="outline-text-5" id="text-org5adae6e">
<ul class="org-ul">
<li>El generador de código toma la <b>RI</b> y genera el código para la
máquina objetivo.</li>

<li>Escribiremos el código objetivo en la forma de lenguaje
ensamblador para facilitar su comprensión, aunque muchos
compiladores generan el código objeto de manera directa.</li>

<li>Es en esta fase de la compilación en la que las propiedades de
la máquina objetivo se convierten en el factor principal.</li>

<li>No sólo es necesario emplear instrucciones que existan en la
máquina objetivo, sino que las decisiones respecto a la
representación de los datos desempeñarán ahora también un papel
principal, tal como cuántos bytes ocuparán las variables.</li>

<li>En esta fase el compilador intenta mejorar el código objetivo
dado por el generador de código.</li>

<li>Dichas mejoras incluyen la selección de modos de
direccionamiento para mejorar el rendimiento, reemplazando las
instrucciones lentas por otras rápidas, y eliminando las
operaciones redundantes o innecesarias.</li>
</ul>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org3b21855" class="outline-3">
<h3 id="org3b21855">23 / 08 / 23</h3>
<div class="outline-text-3" id="text-org3b21855">
</div>
<div id="outline-container-orgb541dbb" class="outline-4">
<h4 id="orgb541dbb">Estructuras de datos principales en un compilador</h4>
<div class="outline-text-4" id="text-orgb541dbb">
<p>
La interacción entre los algoritmos utilizados por las fases de un
compilador y las estructuras de datos que soportan estas fases, es
naturalmente, muy fuerte.
</p>

<p>
Los programadores se esfuerzan por implementar estos algoritmos de
una forma tan eficaz como sea posible, sin aumentar demasiado la
complejidad.
</p>

<p>
De manera ideal, un compilador debería poder compilar un programa
en un tiempo proporcional al tamño del programa, es decir, \(O(n)\)
en tiempo, donde \(n#\) es una medida del tamaño del programa.
</p>

<p>
Este este tema señalaremos algunas de las principales estructuras
de datos que son necesarias para las fases como parte de su
operación y que sirven para comunicar la información entre las
fases.
</p>
</div>

<ul class="org-ul">
<li><a id="org11ea0ed"></a>Tokens<br />
<div class="outline-text-5" id="text-org11ea0ed">
<p>
Cuando un analizador léxico reúne los caracteres en un token,
generalmente representa el token de manera simbólica, es decir,
como valor de un tipo de dato enumerado que representa el
conjunto de tokens del lenguaje fuente.
</p>

<p>
En ocasiones también es necesario mantener la cadena de
caracteres misma u otra información derivada de ella, tal como el
nombre asociado con un token identificador o el valor de un token
número.
</p>

<p>
En la mayoría de los lenguajes el analizador léxico sólo necesita
generar un token a la vez (esto se conoce como búsqueda de
símbolo simple).
</p>

<p>
En este caso se puede utilizar una variable global simple para
mantener la información del token.
</p>

<p>
En otros casos, puede ser necesario un arreglo (u otra
estructura) de tokens.
</p>
</div>
</li>

<li><a id="org4aad96d"></a>Árboles de sintaxis abstracta<br />
<div class="outline-text-5" id="text-org4aad96d">
<p>
Si el analizador sintáctico genera un ASA, por lo regular se
construye como una estructura estándar basada en un apuntador que
se asigna de manera dinámica a medida que se efectúa el análisis
sintáctico.
</p>

<p>
El árbol entero puede entonces conservarse como una variable
simple que apunta al nodo raíz.
</p>

<p>
Cada nodo en la estructura es una estructura, cuyos campos
representan la información recolectada tanto por el analizador
sintáctico, como posteriormente, por el analizador semántico.
</p>

<p>
Por ejemplo, el tipo de dato de una expresión puede conservarse
como un campo en el nodo del ASA para la expresión.
</p>

<p>
En ocasiones para ahorrar espacio, estos campos se asignan de
manera dinámica, o se almacenan en otras estructuras de datos,
como la tabla de símbolos que permiten una asignación y
desasignación selectivas.
</p>

<p>
En realidad, cada nodo del ASA por sí mismo puede requerir
atributos diferentes para ser almacenado, de acuerdo con la clase
de estructura del lenguaje que represente.
</p>

<p>
En esete caso, cada nodo en el ASA puede estar representado por
un registro variable, con cada clase de nodo conteniendo
solamente la información necesaria para ese caso.
</p>
</div>
</li>

<li><a id="org77f6e6a"></a>Tabla de símbolos<br />
<div class="outline-text-5" id="text-org77f6e6a">
<p>
Esta estructura de datos mantiene la información aosicada con los
identificadores: funciones variables, constantes y tipos de
datos.
</p>

<p>
Interactúa con casi todas las fases del compilador: el analizador
léxico, el analizador sintáctico o el analizador semántico que
puede introducir identificadores dentro de la tabal o agregar
tipos de datos y otra información; y las fases de optimización y
generación de código que utlizan la información proporcionada
para efectuar selecciones apropiadas de código objeto.
</p>

<p>
Puesto que tendrá solicitudes de acceso con tanta frecuencia, las
operaciones de elimincación, inserción y acceso necesitan ser
eficientes, preferiblemente operaciones de tiempo constante.
</p>

<p>
Una estrucutra de datos básica para este propósito son las tablas
de dispersión aunque también se pueden utilizar diversas
estructuras de árbol, o se construyen tablas con el apoyo de una
lista o pila.
</p>
</div>
</li>

<li><a id="org20aaabc"></a>Tabla de literales<br />
<div class="outline-text-5" id="text-org20aaabc">
<p>
La búsqueda y la inserción rápida son esenciales para la tabla de
literales, la cual almacena constantes y cadenas utilizadas en el
programa.
</p>

<p>
Sin embargo, una tabla de literales necesita impedir las
eliminaciones porque sus datos se aplican globalmente al programa
y una constante o cadena aparecerá sólo una vez en esta tabla.
</p>

<p>
Es importante en la reducción del tamaño de un programa en la
memoria la permitir la reutilización de constantes y cadenas.
</p>

<p>
También es necesaria para que el generador de código construya
direcciones simbólicas para las literales y para introducir
definiciones de datos en el archivo de código objetivo.
</p>
</div>
</li>

<li><a id="org155c8a5"></a>Código intermedio<br />
<div class="outline-text-5" id="text-org155c8a5">
<p>
De acuerdo con la clase de código intermedio y de las clases de
optimizaciones realizadas, este código puede conservarse como un
arreglo de cadenas, un archivo de texto temporal o bien una lista
de estructuras ligadas.
</p>

<p>
En los compiladores que realizan optimizaciones complejas debe
ponerse particular atención a la selección de representaciones
que permitan una fácil reorganización.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf26b7e2" class="outline-3">
<h3 id="orgf26b7e2">28 / 08 / 23</h3>
<div class="outline-text-3" id="text-orgf26b7e2">
</div>
<div id="outline-container-orgd584b89" class="outline-4">
<h4 id="orgd584b89">Compiladores</h4>
<div class="outline-text-4" id="text-orgd584b89">
</div>
<ul class="org-ul">
<li><a id="org126700a"></a>Introducción<br />
<div class="outline-text-5" id="text-org126700a">
<ul class="org-ul">
<li>La estructura de un compilador se puede ver desde distinto
ángulos.</li>

<li>En temas anteriores describimos sus fases, las cuales
representan la estrucutra lógica de un compilador.</li>

<li>Otros puntos de vista posibles son:

<ul class="org-ul">
<li>La estructura física del compilador</li>

<li>La secuenciación de las operaciones</li>
</ul></li>

<li>La persona que desarrolla el compilador debería estar
familiarizada con tantos puntos de vista de la estructura del
compilador como sea posible, ya que la estructura del
compilador será determinante para su confiabilidad, eficacia,
utilidad y mantenimiento.</li>

<li>En este tema consideraremos otros aspectos en la estructura del
compilador y señalaremos cómo se aplica cada punto de vista.</li>
</ul>
</div>
</li>

<li><a id="orgfdcdb46"></a>Análisis y síntesis<br />
<div class="outline-text-5" id="text-orgfdcdb46">
<ul class="org-ul">
<li>Las operaciones del compilador que analizan el programa fuente
para calcular sus propiedades se clasifican como la parte de
<b>análisis</b> del compilador, mientras que las operaciones
involucradas en la producción del código traducido se conocen
como śintesis del compilador.</li>

<li>Los análisis léxico, sintáctico y semántico pertenecen a la
parte de análisis, mientras que la generación de código es la
síntesis.</li>

<li>Las etapas de optimización pueden involucrar tanto análisis
como síntesis.</li>

<li>El análisis tiende a ser más matemático y a comprendrerse
mejor, mientras que la síntesis requiere de técnicas más
especializadas.</li>

<li>Es útil separar las etapas de análisis de las etapas de
síntesis, de modo que cada una se pueda modificar de manera
independiente respecto a la otra.</li>
</ul>
</div>
</li>

<li><a id="org2c06e3b"></a>Etapa inicial y etapa final<br />
<div class="outline-text-5" id="text-org2c06e3b">
<ul class="org-ul">
<li>Considera al compilador separado en aquellas funciones que
dependen sólo del lenguaje fuente (la etapa inicial <i>front-end</i>)
y aquellas operaciones que dependen únicamente del leguaje
objetivo (etapa final <i>back-end</i>).</li>

<li>Es similar a la división en análisis y síntesis: los
analizadores léxico, sintáctico y semántico son parte de la
etapa inicial, mientras que el generador de código es parte de
la etapa final.</li>

<li>Algo de las optimizaciones puede ser dependiente del objetivo,
y por lo tanto parte de la etapa final, mientras que la
síntesis del código intermedio es a menudo dependiente del
objetivo, y por consiguiente, parte de la etapa inicial. De
manera ideal el compilador estaría estrictamente dividido en
estas dos secciones, con la RI como el medio de comunicación
entre ellas.</li>

<li>Esta estructura es especialmente importante para la
portabilidad del compilador donde se diseña con un enfoque
hacia la modificación, ya sea del código fuente o del código
objetivo.</li>
</ul>
</div>
</li>

<li><a id="org1bc0fa4"></a>Pasadas<br />
<div class="outline-text-5" id="text-org1bc0fa4">
<ul class="org-ul">
<li>Un compilador a menudo encuentra conveniente procesar todo el
programa varias veces antes de generar el código.</li>

<li>Estas repeticiones son conocidas como <b>pasadas</b>.</li>

<li>Después del aso inicial, donde se construye el ASA o una RI a
partir de la fuente, una pasada consiste en procesar la RI
agregando información a ella, alterando su estructura o
produciendo una representación diferente.</li>

<li>Las pasadas pueden corresponder o no a las fases, a menudo una
pasada consistirá de varias etapas.</li>

<li>En realidad, dependiendo del lenguae, un compilador puede ser
de una pasada, en el que todas las fases se presentan en un
paso único.</li>

<li>Esto resulta en una compilación eficaz pero también en un
código objetivo menos eficiente.</li>

<li>La mayoría de los compiladores con optimizaciones utilizan más
de una pasada; por lo regular se emplea una pasada para los
análisis léxico y sintáctico, otra para el análisis semántico y
optimización a nivel del fuente, y una tercera para generación
de código y optimización a nivel del objetivo.</li>

<li>Existen compiladores que pueden emplear incluso más pasadas:
cinco, seis e incluso ocho no son algo fuera de lo común.</li>
</ul>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1b57557" class="outline-3">
<h3 id="org1b57557">29 / 08 / 23</h3>
<div class="outline-text-3" id="text-org1b57557">
</div>
<div id="outline-container-org1f4a898" class="outline-4">
<h4 id="org1f4a898">Gramáticas (libres del contexto)</h4>
<div class="outline-text-4" id="text-org1f4a898">
<p>
\[G=\langle V,T,S,P \rangle\]
</p>

<ul class="org-ul">
<li>\(V\) alfabeto de símbolos no terminales</li>

<li>\(T\) un alfabeto de símbolos terminales</li>

<li>\(S\in V\) símbolo inicial</li>

<li>\(P\) un conjunto de producciones</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3870cdb" class="outline-3">
<h3 id="org3870cdb">30 / 08 / 23</h3>
<div class="outline-text-3" id="text-org3870cdb">
</div>
<div id="outline-container-org0eae446" class="outline-4">
<h4 id="org0eae446">Teoría de Lenguajes de Programación y Teoría de Compiladores</h4>
<div class="outline-text-4" id="text-org0eae446">
<ul class="org-ul">
<li>Hablamos temas atrás sobre cómo las estructuras léxicas y
sintácticas de un lenguaje de programación por lo regular son
especificadas en términos formales y utilizan expresiones
regulares y gramáticas libres del contexto.</li>

<li>Sin embargo, la semántica de un lenguaje de programación todavía
es comúnmente especificada utilizando descripciones en lenguaje
natural.</li>

<li>Estas descripciones son recopiladas en la documentación del
lenguaje de programación.</li>

<li>Cuando se crean nuevos lenguajes de programación, su diseño y
compilador con frecuencia son dearrollados de manera simultánea,
puesto que las técnicas disponibles para los desarrolladores de
compiladores, pueden tener un impacto sobre el diseño del
lenguaje de programación.</li>

<li>Similarmente la manera en que se define un lenguaje de
programación tendrá un impacto fundamental sobre las técnicas
que son necesarias para construir el compilador.</li>

<li>Una situación común es que el lenguaje de programación que se
está implementando sea conocido y tenga un diseño ya existente.</li>

<li>En muchos de estos casos, dichos lenguajes alcanzan el nivel de
lenguaje estándar que son aprobados por organizaciones como ANSI
o ISO.</li>

<li>Esto a menudo no es una tarea sencilla, pero en ocasiones sí
tiene ciertas ventajas debido principalmente a la existencia de
baterías de pruebas estándar.</li>

<li>Ocasionalmente los lenguajes cuentan con una semántica definida
en términos matemáticos, por ejemplo, usando un estilo
operacional.</li>

<li>En estos casos es posible dar una prueba matemática de que un
compilador se adhiere a la definición. Sin embargo, es una tarea
difícil.</li>

<li>El diseño del lenguaje también interfiere con el comportamiento
y estructura de los ambientes de ejecución.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf603ff1" class="outline-4">
<h4 id="orgf603ff1">Manejo de errores</h4>
<div class="outline-text-4" id="text-orgf603ff1">
<ul class="org-ul">
<li>Una de las funciones más importantes de un compilador es su
respuesta a los errores</li>

<li>Una definición de un lenguaje por lo general requerirá no
solamente que los errores estáticos sean detectados por un
compilador, sino también ciertos errores de ejecución.</li>

<li>Esto requiere que un compilador genere código extra, el cual
realizará priuebas de ejecución apropiadas para garantizar que
aún con todos esos errores se provocará un evento apropiado
durante la ejecución. El más simple será detener la ejecución.</li>

<li>A menudo esto no es adecuado, y una definición del lenguaje
puede requerir la presencia de mecanismos para el manejo de
excepciones.</li>

<li>No consideraremos la implementación de un mecanismo así&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org52000fa" class="outline-4">
<h4 id="org52000fa">Autohosting y bootstraping</h4>
<div class="outline-text-4" id="text-org52000fa">
</div>
<ul class="org-ul">
<li><a id="orgb73a651"></a>Lenguaje anfitrión<br />
<div class="outline-text-5" id="text-orgb73a651">
<ul class="org-ul">
<li>Hemos analizado los lenguajes fuente y objetivo como factores
en la estructura de un compilador y la utilidad de separar
cuestiones de los lenguajes fuente y objetivo en etapas inicial
y final.</li>

<li>No hemos mencionado el tercer lenguaje involucrado en el
proceso de construcción de compiladores: el lenguaje en el que
el compilador está escrito.</li>

<li>Para que el compilador se ejecute inmediatamente, este lenguaje
anfitrión tendría que ser lenguaje de máquina.</li>

<li>Así fue como se escribieron los primeros compiladores, puesto
que no existían compiladores todavía.</li>

<li>Un enfoque en la actualidad es escribir el compilador en otro
lenguaje para el cual ya exista un compilador.</li>

<li>Si el compilador existente ya se ejecuta en la máquina
objetivo, entonces necesitamos compilar utlizando el compilador
existente para obtener un programa ejecutable.</li>
</ul>
</div>
</li>

<li><a id="orgfbc7567"></a>Lenguaje anfitrión<br />
<div class="outline-text-5" id="text-orgfbc7567">
<ul class="org-ul">
<li>Si el compilador existente para el lenguaje B se ejecuta en una
máquina diferente a la máquina objetivo, entonces la situación
es un poco más complicada.</li>

<li>La compilación produce entonces un compilador cruzado, es
decir, un compilador que genera código objetivo para una
máquina diferente de aquella en la que puede ejecutarse.</li>
</ul>
</div>
</li>

<li><a id="org7c7763e"></a>Diagramas T<br />
<div class="outline-text-5" id="text-org7c7763e">
<ul class="org-ul">
<li>La situación anterior y muchas otras más complejas se describen
mejor al esquematizar un compilador como un diagrama T.</li>

<li>Un compilador escrito en el lenguaje A (Anfitrión) que traduce
el lenguaje F (Fuente) en lenguaje O (Objetivo) se dibuja como
un diagrama T:</li>
</ul>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">F</th>
<th scope="col" class="org-left">-&gt;</th>
<th scope="col" class="org-left">O</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">A</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Observemos que esto es equivalente a decir que el compilador se
ejecuta en la máquina A. Normalmente esperamos que A sea lo
mismo que O, pero no es necesario que éste sea el caso.</li>

<li>Los diagramas T se pueden combinar en dos formas.</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Erik Rangel Limón</p>
<p class="date">Created: 2024-08-19 Mon 11:43</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
