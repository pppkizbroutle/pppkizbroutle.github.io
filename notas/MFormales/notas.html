<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-19 Mon 11:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Métodos Formales</title>
<meta name="author" content="Erik Rangel Limón" />
<meta name="generator" content="Org Mode" />
<style type="text/css">/* Base */html,body {    background-color: #222;    min-height: 100%;    line-height: 1.5;}body {    color: #fafafa;    font-family: "Courier New";}::selection {    background-color:  #2ecc40;    color: white;}/* Responsive content positioning */@media only screen and (min-width: 1020px) /* Large screens */{    body{        padding: 10vh 25vw;    }}@media only screen and (max-width: 1020px) and (min-width: 750px) /* Small screens */{    body{        padding: 5vh 10vw;    }}@media only screen and (max-width: 750px) /* Small screens */{    body{        padding: 2vh 5vw;    }}/* Headers */h1{font-size: 2.5rem;}h2{font-size: 1.7rem;}h1 > .subtitle, h3, h4, h5, h6{font-size: 1.3rem;}.title{    margin-bottom: 2.5rem;}/* Padding & Margin */* {margin: 0; padding: 0;}pre, blockquote, ul, ol, p, table{    margin: 1rem 0;}h1, h2{margin-top: 2rem; line-height: 2rem;}h3, h4, h5, h6{margin-top: 1rem;}/* Links  */a, a:visited {    color: #01ff70;    text-decoration: underline;}a:hover, a:focus, a:active {    color: #2ecc40;}/* Code */pre {    font-family: "Courier New";    padding: .5rem;    background-color: #333;    padding: 0.5rem;    border-radius: 0.2rem;    font-size: 0.9rem;    color: #EEE;    overflow-x: auto;}.org-keyword{    color: #01ff70;}.org-rainbow-delimiters-depth-1{    color: #2ecc40;}.org-rainbow-delimiters-depth-2{    color: #01ff70;}/* Blockquotes */blockquote {    border-left: 3px solid #01ff70;    padding-left: 1rem;}li{    list-style-position: inside;}/* Tags */.tag{    margin-top: 0.5rem;    display: block;    color: white;    font-size: var(--font-size-xsmall);}.tag > span{		font-weight: 400;    font-size: 0.8rem;    background-color: #444;    text-transform: uppercase;    border-radius: 2px;    width: fit-content;    height: auto;    padding: 1px 5px;}/* Keywords */.todo{    color: #2ecc40;}.done{    color: #444;}/* Overflows */.outline-text-2, .outline-text-3, .outline-text-4{	  max-width: 100%;	  overflow-x: auto;}/* Table */tr:nth-child(even) {    background-color: #333;}th, td{    padding: 0.5rem;    text-align: center;}.underline{    text-decoration: underline;}img{    max-width: 100%;    height: auto;}</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Métodos Formales</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5fb83f0">Contacto</a></li>
<li><a href="#orgdf19345">Rubros</a></li>
<li><a href="#org1e9e688">Notas</a>
<ul>
<li><a href="#org38959d4">14 / 08 / 23</a>
<ul>
<li><a href="#org29e3f0d">Herramientas para verificar programas</a></li>
<li><a href="#org248d6f8">¿Qué son los Métodos Formales?</a></li>
</ul>
</li>
<li><a href="#org3594ab2">16 / 08 / 23</a>
<ul>
<li><a href="#org83d9ef6">Métodos Formales</a></li>
<li><a href="#org5998bc5">Desarrollo de Software</a></li>
<li><a href="#orgc10cd5f">Herramientas de Verificación</a></li>
<li><a href="#orgda594da">Sistemas de deducción</a></li>
</ul>
</li>
<li><a href="#org6b49473">18 / 08 / 23</a>
<ul>
<li><a href="#org1a9b190">Resumen</a></li>
</ul>
</li>
<li><a href="#org8eb8466">21 / 08 / 23</a>
<ul>
<li><a href="#org3a50e5e">Sistemas deductivos</a></li>
<li><a href="#orge4ad96d">Listas de objetos de tipo A</a></li>
</ul>
</li>
<li><a href="#org996da2f">23 / 08 / 23</a>
<ul>
<li><a href="#org9cc05ce">Logical Framework</a></li>
<li><a href="#org8fe6bd8">Listas</a></li>
<li><a href="#org80739c9">Ejemplo, clase pasada</a></li>
<li><a href="#orgcc64f3d">Comportamiento vs implementación</a></li>
</ul>
</li>
<li><a href="#orgdd7576d">25 / 08 / 23</a>
<ul>
<li><a href="#org99073be">Listas (cons)</a></li>
</ul>
</li>
<li><a href="#org9711087">28 / 08 / 23</a>
<ul>
<li><a href="#orge7ba35b">Software Testing</a></li>
</ul>
</li>
<li><a href="#org3b6d18b">30 / 08 / 23</a>
<ul>
<li><a href="#org3594cc7">Haskell</a></li>
</ul>
</li>
<li><a href="#orgce9fb1d">04 / 09 / 23</a>
<ul>
<li><a href="#orge1e0e00">Software Testing</a></li>
</ul>
</li>
<li><a href="#orgd882a2d">11 / 09 / 2023</a>
<ul>
<li><a href="#orge70de8a">QuickCheck</a></li>
<li><a href="#org9a3ad86">Árboles Binarios de Búsqueda</a></li>
</ul>
</li>
<li><a href="#org70d5514">12 / 09 / 23</a>
<ul>
<li><a href="#org376df73">Ayudantía QuickCheck</a></li>
</ul>
</li>
<li><a href="#org06f6f0f">18 / 09 / 23</a>
<ul>
<li><a href="#orgd14e24a">Análisis Estático</a></li>
</ul>
</li>
<li><a href="#org9b24d75">20 / 09 / 23</a>
<ul>
<li><a href="#org18e72d7">Análisis Estático (Interpretación Abstracta)</a></li>
</ul>
</li>
<li><a href="#orgb151b53">22 / 09 / 23</a>
<ul>
<li><a href="#org31782c6">Frama C</a></li>
<li><a href="#orga6562e2">Interpretación abtracta</a></li>
</ul>
</li>
<li><a href="#org0f95c23">27 / 09 / 23</a>
<ul>
<li><a href="#orgb319b1d">Lógica Axiomática</a></li>
</ul>
</li>
<li><a href="#org0452855">09 / 10 / 23</a>
<ul>
<li><a href="#org9c92d21">Frama C</a></li>
</ul>
</li>
<li><a href="#org92d32ca">11 / 10 / 23</a>
<ul>
<li><a href="#org52c2f16">Arreglos</a></li>
</ul>
</li>
<li><a href="#org4e081ce">20 / 10 / 23</a>
<ul>
<li><a href="#orge7e4bbb">Lógica de Hoare</a></li>
</ul>
</li>
<li><a href="#org229fa4d">08 / 11 / 23</a>
<ul>
<li><a href="#org1ccdb93">Lógica de orden superior</a></li>
</ul>
</li>
<li><a href="#org9531af5">13 / 11 / 23</a>
<ul>
<li><a href="#org314a2ca">Sistemas de tipos</a></li>
</ul>
</li>
<li><a href="#org61b4733">15 / 11 / 23</a>
<ul>
<li><a href="#org8dae095">Sistema</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc4d8f72">Bibliografía</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5fb83f0" class="outline-2">
<h2 id="org5fb83f0">Contacto</h2>
<div class="outline-text-2" id="text-org5fb83f0">
<ul class="org-ul">
<li><p>
Lourdes
</p>

<p>
lug1zhuezca@ciencias.unam.mx
</p>

<p>
Cubículo 19 Depto Mate.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf19345" class="outline-2">
<h2 id="orgdf19345">Rubros</h2>
<div class="outline-text-2" id="text-orgdf19345">
<ul class="org-ul">
<li>Prácticas 30%</li>
<li>Tareas 40%</li>
<li>Proyecto 30%</li>
</ul>
</div>
</div>

<div id="outline-container-org1e9e688" class="outline-2">
<h2 id="org1e9e688">Notas</h2>
<div class="outline-text-2" id="text-org1e9e688">
</div>
<div id="outline-container-org38959d4" class="outline-3">
<h3 id="org38959d4">14 / 08 / 23</h3>
<div class="outline-text-3" id="text-org38959d4">
</div>
<div id="outline-container-org29e3f0d" class="outline-4">
<h4 id="org29e3f0d">Herramientas para verificar programas</h4>
<div class="outline-text-4" id="text-org29e3f0d">
<ul class="org-ul">
<li>Haskell: Quick Check</li>
<li>C: Frama-C (Ocaml)</li>
<li>General: Coq (Ocaml)</li>
</ul>
</div>
</div>

<div id="outline-container-org248d6f8" class="outline-4">
<h4 id="org248d6f8">¿Qué son los Métodos Formales?</h4>
<div class="outline-text-4" id="text-org248d6f8">
<p>
Engloba las herramientas computacionales o matemáticas para
verificar (demostrar) sistemas computacionales (tanto de <i>hardware</i>
como de <i>software</i>).
</p>

<p>
Éstas aseguran que una implementación cumple una <b>especificación</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-org3594ab2" class="outline-3">
<h3 id="org3594ab2">16 / 08 / 23</h3>
<div class="outline-text-3" id="text-org3594ab2">
</div>
<div id="outline-container-org83d9ef6" class="outline-4">
<h4 id="org83d9ef6">Métodos Formales</h4>
<div class="outline-text-4" id="text-org83d9ef6">
<p>
Herramientas computacionales / matemáticas para la <b>verificación</b> de
sistemas computacionales.
</p>

<p>
<b>Verificación</b>: Asegurar que una especificación se cumple en una
implementación.
</p>
</div>
</div>

<div id="outline-container-org5998bc5" class="outline-4">
<h4 id="org5998bc5">Desarrollo de Software</h4>
<div class="outline-text-4" id="text-org5998bc5">
<p>
El desarrollo de Software consiste de 4 fases.
</p>

<ul class="org-ul">
<li>Análisis</li>
<li>Especificación</li>
<li>Desarrollo (implementación)</li>
<li><i>Verificación</i></li>
<li>Mantenimiento</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orgb2f6a92"></a>Métodos Formales<br />
<div class="outline-text-5" id="text-orgb2f6a92">
<p>
Durante todo este proceso de desarrollo se pueden incluir métodos
formales; entre ellos incluidos, pero no limitadas:
</p>

<ul class="org-ul">
<li>Casos de uso</li>
<li>Contratos / firmas / interfaces</li>
<li>Tipos o verificación de tipos</li>
<li>Ejecución simbólica</li>
<li>Pruebas unitarias</li>
</ul>
</div>
</li>

<li><a id="org88b0a9a"></a>Propiedades a verificar<br />
<div class="outline-text-5" id="text-org88b0a9a">
<ul class="org-ul">
<li>Alto nivel: Propiedades dadas en la especificación.</li>

<li>Bajo nivel: Propiedades a nivel de hardware o software para
verificar que el sistema se instaló correctamente (por ejemplo,
los sensores).</li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgc10cd5f" class="outline-4">
<h4 id="orgc10cd5f">Herramientas de Verificación</h4>
<div class="outline-text-4" id="text-orgc10cd5f">
<p>
Una de las más conocidas son:
</p>

<ul class="org-ul">
<li>Los sistemas de tipos de un lenguaje de programación</li>

<li>Lógica de Hoare: Se analizan las propiedades que se deben
cumplir antes de ejecutar un sistema (precondiciones) y las
propiedades que se deben cumplir después de la ejecución
(postcondiciones).</li>

<li><b>Pruebas unitarias</b></li>

<li>Lógicas temporales (LTL <i>Linear tree logic</i> y CTL <i>Computational
tree logic</i>)</li>
</ul>
</div>
</div>

<div id="outline-container-orgda594da" class="outline-4">
<h4 id="orgda594da">Sistemas de deducción</h4>
<div class="outline-text-4" id="text-orgda594da">
<p>
\[\infer{0\in\mathbb{N}}{}\]
</p>

<p>
\[\infer{Suc\ n \in \mathbb{N}}{n \in \mathbb{N}}\]
</p>

<p>
Para demostrar que \(Suc\ n\) es Natural, basta demostrar que \(n\) es
un Natural.
</p>
</div>
</div>
</div>

<div id="outline-container-org6b49473" class="outline-3">
<h3 id="org6b49473">18 / 08 / 23</h3>
<div class="outline-text-3" id="text-org6b49473">
</div>
<div id="outline-container-org1a9b190" class="outline-4">
<h4 id="org1a9b190">Resumen</h4>
<div class="outline-text-4" id="text-org1a9b190">
<p>
Entonces, los métodos formales consiste en la verificación de
sistemas de cómputo tando de <i>software</i> como de <i>hardware</i>.
</p>

<p>
Son herramientas computacionales o matemáticas para la
abstracción, razonamientos y demostraciones por medio de sistemas
de deducción, que funcionan con un conjunto de reglas de
inferencia.
</p>

<p>
Estas reglas de inferencia modelan comportamientos; y pueden ser
utilizados par hacer juicios sobre objetos.
</p>
</div>
</div>
</div>

<div id="outline-container-org8eb8466" class="outline-3">
<h3 id="org8eb8466">21 / 08 / 23</h3>
<div class="outline-text-3" id="text-org8eb8466">
</div>
<div id="outline-container-org3a50e5e" class="outline-4">
<h4 id="org3a50e5e">Sistemas deductivos</h4>
<div class="outline-text-4" id="text-org3a50e5e">
<p>
Sirven para formalizar o abstraer definiciones, propiedades o
cálculos.
</p>

<p>
Estos sistemas deductivos funcionan a partir de reglas básicas
(axiomáticas) en donde no hay suposiciones o premisas.
</p>

<p>
También las reglas pueden formarse a partir de
</p>

<p>
\[\infer{conclusion}{premisas}\]
</p>

<p>
Hay dos formas de leer las reglas; hacia adelante para llegar a
conclusiones, o dada una condición a verificar se lee hacia atrás
para corroborar la condición. <b>Éstas se pueden combinar</b>
</p>
</div>
</div>

<div id="outline-container-orge4ad96d" class="outline-4">
<h4 id="orge4ad96d">Listas de objetos de tipo A</h4>
<div class="outline-text-4" id="text-orge4ad96d">
<p>
\[\infer{[\ ]\ \textit{list}_A}{}\]
</p>

<p>
\[\infer{a:\ell\ \textit{list}_A}{a\ A & \ell\ \textit{list}_A}\]
</p>

<p>
\[\infer{snoc(\ell,a)\ \textit{list}_A}{a\ A & \ell\ \textit{list}_A}\]
</p>
</div>
</div>
</div>


<div id="outline-container-org996da2f" class="outline-3">
<h3 id="org996da2f">23 / 08 / 23</h3>
<div class="outline-text-3" id="text-org996da2f">
</div>
<div id="outline-container-org9cc05ce" class="outline-4">
<h4 id="org9cc05ce">Logical Framework</h4>
<div class="outline-text-4" id="text-org9cc05ce">
<p>
Un meta lenguaje para la especificación de sistemas de deducción.
</p>
</div>
</div>

<div id="outline-container-org8fe6bd8" class="outline-4">
<h4 id="org8fe6bd8">Listas</h4>
<div class="outline-text-4" id="text-org8fe6bd8">
<p>
La descripción básica es:
</p>

<ul class="org-ul">
<li>Una secuencia de elementos</li>
<li>Homogéneas</li>
<li>Finitas</li>
<li>Con un orden</li>
</ul>


<p>
Sea este conjunto de listas \(L\)
</p>
</div>
</div>

<div id="outline-container-org80739c9" class="outline-4">
<h4 id="org80739c9">Ejemplo, clase pasada</h4>
<div class="outline-text-4" id="text-org80739c9">
<p>
\[\infer{[\ ]\ \textit{list}_A}{}\] Ln
</p>

<p>
\[\infer{a:\ell\ \textit{list}_A}{a\ A & \ell\ \textit{list}_A}\] <i>cons</i>
</p>

<p>
\[\infer{\ell;a\ \textit{list}_A}{a\ A & \ell\ \textit{list}_A}\] <i>snoc</i>
</p>

<p>
<b>Propiedad</b>: las listas generadas con <i>cons</i> son las mismas que las
que se generan con <i>snoc</i>.
</p>

<p>
<b>Dem</b>: Sea \(\ell\) una lista en \(L\).
</p>

<p>
Si \(\ell\) es la secuencia vacía
</p>

<p>
entonces Ln puede constuir la lista vacía en ambos sistemas.
</p>

<p>
Si \(\ell\) es una secuencia no vacía
</p>
</div>
</div>

<div id="outline-container-orgcc64f3d" class="outline-4">
<h4 id="orgcc64f3d">Comportamiento vs implementación</h4>
<div class="outline-text-4" id="text-orgcc64f3d">
<ul class="org-ul">
<li>Intensional (Comportamiento): Dar las condiciones necesarias y suficiendtes para
definir un objeto.</li>

<li>Extensional (Extensional): Mostrar los objetos</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdd7576d" class="outline-3">
<h3 id="orgdd7576d">25 / 08 / 23</h3>
<div class="outline-text-3" id="text-orgdd7576d">
</div>
<div id="outline-container-org99073be" class="outline-4">
<h4 id="org99073be">Listas (cons)</h4>
<div class="outline-text-4" id="text-org99073be">
<div class="org-src-container">
<pre class="src src-haskell">take :: Int -&gt; [a] -&gt; [a]
take 0 _ = []
take _ [] = []
take n (a:l) = a : (take (n-1) l)

drop :: Int -&gt; [a] -&gt; [a]
drop 0 l = l
drop _ [] = []
drop n (a:l) = drop (n-1) l

(++) :: [a] -&gt; [a] -&gt; [a]
(++) [] l = l
(++) (x:xs) l = x : (++) xs l
</pre>
</div>

<p>
\[\infer{\texttt{take(n,l,[])}}{\texttt{n=0}}\]
</p>

<p>
\[\infer{\texttt{take(n,[],[])}}{}\]
</p>

<p>
\[\infer{\texttt{take(n,a:l, a:l')}}{\texttt{m=n-1} & \texttt{take()}}\]
</p>

<p>
¿Será cierto que <code>take n l ++ drop n l = l</code>?
</p>

<p>
Siguiendo por inducción.
</p>

<p>
<b>Caso base</b>: <code>l = []</code>
</p>

<p>
<b>Paso inductivo</b>:
</p>
</div>
</div>
</div>

<div id="outline-container-org9711087" class="outline-3">
<h3 id="org9711087">28 / 08 / 23</h3>
<div class="outline-text-3" id="text-org9711087">
</div>
<div id="outline-container-orge7ba35b" class="outline-4">
<h4 id="orge7ba35b">Software Testing</h4>
<div class="outline-text-4" id="text-orge7ba35b">
<p>
Consiste la calidad de un proudcto (software o un servicio) además
de verificarlo.
</p>

<p>
Son técnicas que permiten evaluarlo al:
</p>

<ul class="org-ul">
<li>Ejecutar el programa o la aplicación con la intención de
encontrar fallas</li>

<li>Verificar si cunple los requerimientos del diseño.</li>

<li>Analizar si responde ocrrectamente a todo tipo de entradas.</li>

<li>Evaluar si realiza las acciones en un tiempo razonable.</li>

<li>Verificar si es útil y puede instalarse y usarse en los
contextos para el cual fue diseñado.</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="orgc22d08d"></a>Consideraciones<br />
<div class="outline-text-5" id="text-orgc22d08d">
<p>
Dado que no se pueden realizar una cantidad infinita de <i>tests</i> para
validad un producto sólo se pueden buscar fallas o faltas en el
producto en lugares específicos.
</p>

<p>
Se realiza sobre el producto ya terminado o una versión del mismo
que ya es posible ejecutar.
</p>

<p>
Fase fundamental del desarrollo de software y depende la
metodología del desarrollo que determina el uso y forma de
aplicación de los tests.
</p>
</div>
</li>

<li><a id="orge19c291"></a>Estilos<br />
<div class="outline-text-5" id="text-orge19c291">
<ul class="org-ul">
<li>Estático: Dedicado a la verificación y no requiere ejecutar el
código (análisis léxico)</li>

<li>Dinámico: Ejecución controlada bajo ciertas circunstancias para
análisis y validación de resultados.</li>

<li>Pasivo: Verificar el comportamiento del producto si interactuar
con él.</li>

<li>De exploración: Diseño y ejecución simultáneos para el diseño
de pruebas.</li>

<li>Método de caja: considera el punto de vista del <i>tester</i> para el
diseño de las pruebas y se usan en niveles de seguridad,
integración y de sistema:

<ul class="org-ul">
<li><b>white-box</b> para verificar estrucutras internas</li>

<li><b>black-box</b> para verificaciones de alto nivel</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org88c8a18"></a>Niveles<br />
<div class="outline-text-5" id="text-org88c8a18">
<ul class="org-ul">
<li>Unit Testing:

<ul class="org-ul">
<li>Evaluación de unidades ó módulos completados y antes de
integrarse con otros módulos.</li>

<li>El programador realiza los tests para mostrar que el código
satisface el diseño.</li>

<li>Pruebas documentadas con objetivo - procedimiento -
resultado.</li>

<li>Alcance de las pruebas (número de líneas ejecutadas y ramas
cubiertas).</li>

<li><i>Test-driven development</i> (TDD) método usado en desarrollos
ágiles u en donde los test se dieñan antes del código.</li>
</ul></li>

<li>Integration Testing:

<ul class="org-ul">
<li>Evaluación de un sistema integrado una cez que las partes fueron
evaluadas individualmente.</li>

<li>Para verificar que los módulos y sus interfaces trabajan en
conjunto correctamente.</li>
</ul></li>

<li>System Testing:

<ul class="org-ul">
<li>Verificar que la implementación es correcta con respecto a
los requerimientos del sistema.</li>

<li>Evaluación realizada de forma independiente por un grupo de
pruebas en donde los casos de prueba y sus ejecuciones son
usados.</li>

<li>Incluye pruebas de seguridad, de uso y de desempeño.</li>
</ul></li>

<li>Performance Testing:

<ul class="org-ul">
<li>Tiene por objeto asegurar que el desempeño del sistema
respeta los límites establecidos por los requerimientos.</li>

<li>Incluye pruebas de desempeño en tiempo, <i>stress testing</i>
simulación de uso, etc&#x2026; Y se pueden utilizar herramientas
para estas simulaciones.</li>
</ul></li>

<li>Acceptance Testing:

<ul class="org-ul">
<li>Pruebas controladas dirigidas al cliente o a situaciones
reales de uso para verificar que el producto cumple con los
requerimientos.</li>
</ul></li>

<li>Functional Testing:

<ul class="org-ul">
<li>Verificación de funciones al simular escenarios basados en
los requerimientos.</li>
</ul></li>

<li>Regresion Testing:

<ul class="org-ul">
<li>Verificar si algunas características degradas o rompen
algunas funcionalidades.</li>
</ul></li>

<li>Stress Testing:

<ul class="org-ul">
<li>Probar las condiciones extremas que puede resistir el sistema
antes de fallar (no son funcionales).</li>
</ul></li>

<li>Usability Testing:

<ul class="org-ul">
<li>Validar qué tan bien puede usar el cliente final el sistema
para completar una tarea.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org9e8402a"></a>Técnicas<br />
<div class="outline-text-5" id="text-org9e8402a">
<p>
Existen diferentes técnicas o tácticas para llevar a cabo las
pruebas de productos, dependen del tipo de software o del
propósito de la prueba.
</p>

<ul class="org-ul">
<li>Pruebas de instalación.</li>

<li>Pruebas de compatibilidad respecto a aplicaciones, sistemas
operativos, etc.</li>

<li>Pruebas de aceptación (ambientes especiales o hardware).</li>

<li><i>alpha testing</i>: simulaciones antes de pasar a otras pruebas.</li>

<li><i>beta testing</i>: después de las pruebas <i>alpha</i> para aceptación del
usuario.</li>

<li>Pruebas funcionales para evaluar algún requerimiento o función
especial.</li>
</ul>
</div>
</li>

<li><a id="orgcd29bf3"></a>Ciclo de pruebas<br />
<div class="outline-text-5" id="text-orgcd29bf3">
<p>
El diseño y aplicación de pruebas o <i>testing</i> se realiza en uno o
varios momentos del desarrollo de software y va de la mano con el
modelo de desarrollo que se usa.
</p>

<p>
En la práctica depende del equipo de desarrollo y la metodología
usada.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org3b6d18b" class="outline-3">
<h3 id="org3b6d18b">30 / 08 / 23</h3>
<div class="outline-text-3" id="text-org3b6d18b">
</div>
<div id="outline-container-org3594cc7" class="outline-4">
<h4 id="org3594cc7">Haskell</h4>
<div class="outline-text-4" id="text-org3594cc7">
<p>
<i>Haskell</i> es un lenguaje de programación funcional, fuertemente
tipado, de muy alto nivel, cuenta con transparencia referencial
(no hay manejo de memoria explícito), y es turing completo.
</p>

<p>
El que este lenguaje sea de muy alto nivel quiere decir que
propone nuevos mecanismos para razonar programas, y en particular
el de <i>Haskell</i> los programas funcionan por medio de un razonamiento
ecuacional, de manera que un programa es un conjunto de
ecuaciones; así mismo su mecanismo está basado fuertemente en la
inducción.    
</p>

<p>
Por ejemplo, el tipo de dato lista en haskell se definiría de la
siguiente manera:
</p>

<div class="org-src-container">
<pre class="src src-haskell">data List a = []
            | Cons a (List a)
</pre>
</div>

<p>
El sistema de tipos de <i>Haskell</i> implementa el sistema F, el cual se
le conoce como polimorfismo ad-hoc y corresponde con la lógica de
2do orden. De esta manera <i>todo programa tiene un tipo</i> y se
verifica en tiempo de compilación.
</p>

<p>
Sin embargo el tipo de una función por lo general no es una buena
o completa especificación de lo que hace, y por lo que le hace
falta documentación para saber exactamente qué es lo que debería
hacer dicha función.
</p>

<p>
Sin embargo, en <i>Haskell</i> quisiéramos descripciones lógicas que
respeten los tipos, y sigan patrones; es decir, que podamos
definir propiedades de los programas (<i>program testing</i>, <i>property
based testing</i>).
</p>

<p>
Siendo <code>rev</code> la función que calcula la reversa de las listas; como
ejemplo mostramos la siguiente propiedad:
</p>

<div class="org-src-container">
<pre class="src src-haskell">p1 :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool
p1 l1 l2 = rev (l1 ++ l2) == rev l2 ++ rev l1
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgce9fb1d" class="outline-3">
<h3 id="orgce9fb1d">04 / 09 / 23</h3>
<div class="outline-text-3" id="text-orgce9fb1d">
</div>
<div id="outline-container-orge1e0e00" class="outline-4">
<h4 id="orge1e0e00">Software Testing</h4>
<div class="outline-text-4" id="text-orge1e0e00">
</div>
<ul class="org-ul">
<li><a id="orge882ed3"></a>QuickCheck<br />
<div class="outline-text-5" id="text-orge882ed3">
<p>
Es una herramineta para <i>testing</i> o para evaluar automáticamente
programas en <i>Haskell</i>.
</p>

<ul class="org-ul">
<li>Provee una especificación del programa (propiedades de funciones)</li>

<li>QuickCheck evalúa las propiedades generando casos de forma
aleatoria.</li>

<li>El lenguaje usado es el propio de <i>Haskell</i>.</li>
</ul>
</div>
</li>

<li><a id="org9381192"></a>Programación funcional<br />
<div class="outline-text-5" id="text-org9381192">
<ul class="org-ul">
<li>Es un estilo de programación cuyo método básico de computación
es la aplicación de funciones a argumentos.</li>

<li>Pertenece a la programación declarativa donde la estructura y
los elementos en un programa se expresan de forma lógica, sin
describir el control del flujo de datos.

<ul class="org-ul">
<li>Describir qué es lo que el programa debe realizar en lugar de
decir cómo realizarlo.</li>

<li>Programación de alto nivel, sin efectos (transparencia
referencial, sin manejo explícito de memoria)</li>

<li>Con una clara correspondencia matemática.</li>
</ul></li>

<li>Haskell tiene funciones de orden superior, transparencia
referencial, inferencia de tipos, semántica perezosa, módulos,
polimorfismo, etc..</li>
</ul>


<p>
Las ventajas de <i>Haskell</i> como lenguaje de alto nivel son muchas,
entonces ¿Por qué hacer testing en programas de <i>Haskell</i>?
</p>
</div>
</li>

<li><a id="orgeb648c4"></a>Property-based testing en QuickCheck<br />
<div class="outline-text-5" id="text-orgeb648c4">
<p>
Las propiedades de programase expresan como funciones con el
prefijo <code>prop_</code>.
</p>

<ul class="org-ul">
<li>Están cuantificadas universalmente sobre sus parámetros.</li>

<li>Sólo pueden ser de tipo monomórfico.</li>

<li>Si se usa con un argumento polimórfico, las pruebas o <i>tests</i> se
debem restringir a un tipo particular.</li>

<li>La propiedad debe ser decidible, es decir de tipo <code>Bool</code>.</li>

<li>También pueden ser una combinación de propiedades.</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org3dd09c9"></a>Ejemplo<br />
<div class="outline-text-6" id="text-org3dd09c9">
<p>
Propiedad simple:
</p>

<div class="org-src-container">
<pre class="src src-haskell">prop_Revrev :: [a] -&gt; Bool
prop_Revrev xs = reverse (reverse xs) == xs
  where
    types = xs :: [Int]
</pre>
</div>

<p>
Propiedad condicional:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ordered xs = and (zipWith (&lt;=) xs (drop 1 xs))
insert x xs = takeWhile (&lt;x) xs ++ [x] ++ dropWhile (&lt;x) xs

prop_Insert x xs = ordered xs ==&gt; ordered (insert x xs)
  where
    types = x :: Int
</pre>
</div>

<p>
Propiedad cuantificada:
</p>

<div class="org-src-container">
<pre class="src src-haskell">prop_Insert2 x = forAll orderedList $ \xs -&gt; ordered (insert x xs)
  where
    types = x :: Int
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgd882a2d" class="outline-3">
<h3 id="orgd882a2d">11 / 09 / 2023</h3>
<div class="outline-text-3" id="text-orgd882a2d">
</div>
<div id="outline-container-orge70de8a" class="outline-4">
<h4 id="orge70de8a">QuickCheck</h4>
<div class="outline-text-4" id="text-orge70de8a">
<ul class="org-ul">
<li>Nos sirve para probar software a través de propiedades generales
que el código / implementación debe cumplir.</li>

<li>¿Cómo diseñamos pruebas para código funcional?

<ul class="org-ul">
<li>Que una función tenga su tipo especificado muchas veces no es
suficiente para asegurar que se va a realizar una tarea
específica.</li>
</ul></li>

<li><p>
Una estrategia para hacer buenas propiedades es no repetir
código para verificar que hace lo que se le pide.
</p>

<div class="org-src-container">
<pre class="src src-haskell">prop_Reverse :: [Int] -&gt; Property
prop_Reverse xs = reverse xs === ???

prop_Reverse xs = reverse (reverse xs) === xs
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-org9a3ad86" class="outline-4">
<h4 id="org9a3ad86">Árboles Binarios de Búsqueda</h4>
<div class="outline-text-4" id="text-org9a3ad86">
<div class="org-src-container">
<pre class="src src-haskell">data BST k v = Leaf | Branch (BST k v) k v (BST k v) deriving (Show, Eq, Generic)

find :: Ord k =&gt; k -&gt; BST k v -&gt; Maybe v
nil :: BST k v
insert :: Ord k =&gt; k -&gt; v -&gt; BST k v -&gt; BST k v
delete :: Ord k =&gt; k -&gt; BST k v -&gt; BST k v
union :: Ord k =&gt; BST k v -&gt; BST k v -&gt; BST k v

toList :: BST k v -&gt; [(k, v)]
keys :: BST k v -&gt; [k]
</pre>
</div>

<p>
<b>Generación de pruebas:</b>
</p>

<div class="org-src-container">
<pre class="src src-haskell">instance (Ord k, Arbitrary k, Arbitray v) =&gt; Arbitrary (BST k v) where
  arbitrary = do
    kvs &lt;- arbitrary
    return $ foldr (uncurry insert) nil (kvs :: [(k, v)])
  shrink = genericShrink
</pre>
</div>

<ul class="org-ul">
<li><code>Arbitrary</code> es la clase de tipos para generar aleatoriamente
valores para las pruebas.</li>

<li id="=arbitrary">Gen a= donde <code>Gen</code> esel tipo de generadores para
cierto tipo.</li>

<li id="=shrink">a -&gt; [a]= Es una función que colapsa valores y reducir
en complejidad los casos de prueba.</li>
</ul>


<p>
Para éste tipode pruebas es importante identificar las invariantes
de las funciones, es decir, afirmaciones lógicas que se cumplen en
alguna fase de ejecución.
</p>

<p>
Éstas invariantes ayudan a razonar respecto a la corrección de las
funciones y complementan la especificación dada por los tipos.
</p>

<p>
En el caso de árboles binarios de búsqueda, cualquier operación
debe respetar el orden de las llaves.
</p>
</div>
</div>
</div>

<div id="outline-container-org70d5514" class="outline-3">
<h3 id="org70d5514">12 / 09 / 23</h3>
<div class="outline-text-3" id="text-org70d5514">
</div>
<div id="outline-container-org376df73" class="outline-4">
<h4 id="org376df73">Ayudantía QuickCheck</h4>
<div class="outline-text-4" id="text-org376df73">
<div class="org-src-container">
<pre class="src src-haskell">data Set a = Elem a (Set a) | Empty deriving (Show, Eq)

insert a Empty = Elem a Empty
insert a (Elem b s) = if a == b then Elem a s else Elem b (insert a s)

instance (Arbitrary a, Eq a) =&gt; Arbitrary (Set a) where
  arbitrary = do
    s &lt;- arbitrary
    a &lt;- arbitrary
    oneof [return Empty, return (Elem a s)]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org06f6f0f" class="outline-3">
<h3 id="org06f6f0f">18 / 09 / 23</h3>
<div class="outline-text-3" id="text-org06f6f0f">
</div>
<div id="outline-container-orgd14e24a" class="outline-4">
<h4 id="orgd14e24a">Análisis Estático</h4>
<div class="outline-text-4" id="text-orgd14e24a">
</div>
<ul class="org-ul">
<li><a id="org75e819e"></a>Software Testing y Property-Based Testing<br />
<div class="outline-text-5" id="text-org75e819e">
<p>
Son para evalua la calidad de un prdoucto (software o servicio)
</p>

<ul class="org-ul">
<li>Usualmente, las herraminetas para <i>testing</i> están dirigidas a
lenguajes de programación imperativos / estructurados /
orientados a objetos.</li>

<li>Realizan pruebas de las propiedades basado en las condiciones
de los programas:

<ul class="org-ul">
<li>Cubrir la mayor parte de entradas posibles.</li>

<li>Contracción de los casos de prueba para ajustarse a als
condiciones.</li>

<li>Se pueden reproducir las pruebas</li>
</ul></li>

<li>Idea inicial en <code>QuickCheck</code></li>
</ul>
</div>
</li>

<li><a id="orgc093083"></a>Verificación<br />
<div class="outline-text-5" id="text-orgc093083">
<p>
Property-Based Testing no reemplaza las pruebas unitarias o
cualquier otro método para verificar programas.
</p>

<ul class="org-ul">
<li>Existen diferentes usos de testing usando propiedades para
muchos lenguajes de programación:

<ul class="org-ul">
<li>Jest: <a href="https://jesths.io/">https://jesths.io/</a></li>

<li>Hypothesis: <a href="https://hypothesis.readthedocs.io/en/latest/">https://hypothesis.readthedocs.io/en/latest/</a></li>
</ul></li>
</ul>


<p>
Muchos aspectos de la verificación dependen del lenguaje de
programación y de la especificación del sistema o programa.Las
herramientas matemáticas que existen para realizar verificación
son muchas:
</p>

<ul class="org-ul">
<li>Semánticas para lenguajes de programación. (definidos en cada
lenguaje)

<ul class="org-ul">
<li>Semántica operacional</li>

<li>Semántica estática</li>

<li>Semántica axiomática.</li>
</ul></li>

<li>Análisis Estático</li>

<li>Interpretación Abstracta</li>

<li>Verificación de Modelos (lógicas temporales)</li>

<li>Ejecución simbólica</li>
</ul>
</div>
</li>

<li><a id="org8e640f3"></a>Abstracciones y análisis<br />
<div class="outline-text-5" id="text-org8e640f3">
<p>
La noción de <b>abstracción</b> es difícil de definer, se recurre a
explicarlo, ilustrarlo, modelarlo o entenderlo.
</p>

<p>
En el desarrollo de software, la abtracción ofrece ventajas como
simplicidad, generalidad y precisión para el proceso de
desarrollo y que es orientado a mostrar que el producto es
correcto y completo.
</p>

<p>
Una de lsa técnicas más usuales para probar / verificar / evaluar
un programa o un sistema es realizar un análisis (estático) del
mismo:
</p>

<ul class="org-ul">
<li>Análisis de las definiciones</li>

<li>Análisis de los datos y / o resultados</li>

<li>Análisis de funciones o módulos</li>
</ul>
</div>
</li>

<li><a id="org87d2286"></a>Especificar y Analizar<br />
<div class="outline-text-5" id="text-org87d2286">
<p>
Las formas de llevar a cabo los análisis dependen del sistema, el
foco a analizar, etc.
</p>

<ul class="org-ul">
<li>El análisis simbólico: para verificar circuitos lógicos.</li>

<li>La ejecución simbólica: técnica de análisis para raoznar
respecto a los programas, en particular sobre valores de
entrada y salida (intérpretes o máquinas virtuales).</li>

<li>La simulación simbólica: Usando un sistema de transiciones se
pueden modelar los estados de un sistema de forma discreta en
tiempo (Teoría de Latices).</li>

<li>Análisis estático de programas: Usar alguna de las semánticas
(denotacional, axiomática u operacional) para estudiar el
software, también usar la interpretación abstracta.</li>
</ul>
</div>
</li>

<li><a id="org742d4cc"></a>Sistemas para abstracciones<br />
<div class="outline-text-5" id="text-org742d4cc">
<p>
Existen herramientas y ambientes para diseñar especificaciones a
partir de requerimientos.
</p>

<p>
Las abstracciones necesarias para datos y funciones son
integradas en lenguajes de especificación especializados:
</p>

<ul class="org-ul">
<li>Z specification language</li>

<li>Vienna Development Method (VDM)

<ul class="org-ul">
<li>Es un método formal orientado a modelos:

<ul class="org-ul">
<li>Especificaciones como modelos de un sistema.</li>

<li>Un sistema es diseñado por sus especificaciones donde cada
una es más concreta que la anterior.</li>

<li>En cada iteración o paso de desarrollo existen
refinamientos formales</li>

<li>Cada uno de los pasos son verificados</li>

<li>La corrección del sistema está determinada por la
corrección de cada uno de los pasos.</li>
</ul></li>

<li>Tiene su propio lenguaje formal (VDM-SL) para describir datos
y funcionalidades mediante tipos de datos, secuencias y
funciones.</li>

<li>Las operaciones se definen usando pre y post condiciones para
caracterizar su comportamiento, o usando los algoritmos
diseñados para ellas.</li>
</ul></li>

<li>B-Method</li>
</ul>
</div>
</li>

<li><a id="orgd48cfe8"></a>Sistemas de tipos<br />
<div class="outline-text-5" id="text-orgd48cfe8">
<p>
Las definiciones de los lenguajes de programación (sintaxis y
semántica) son herramientas bien establecidas para realizar
especificaciones.
</p>

<ul class="org-ul">
<li>Fases o procesos de compilación o interpretación pueden ser
usados como métodos formales.</li>

<li>Un verificador de tipo (type-checker) es útil para realizar
verificaciones estáticas automáticas con la desventaja de que
es un proceso indecidible.</li>

<li>Un type-checker puede ser extendido o enriquecido con
mecanismos para obtener "pruebas de correción"
(proof-obligations) para demostrar o verificar las partes
indecidibles y que no puede ser automatizado.</li>

<li>La ejecución simbólica usando las reglas de la semántica
operacional de un lenguaje también puede ser usado como método
formal.</li>
</ul>
</div>
</li>

<li><a id="org74592a0"></a>Semántica Axiomática<br />
<div class="outline-text-5" id="text-org74592a0">
<ul class="org-ul">
<li>Sistema de deducción formal que consiste de reglas de juicios
sobre precondiciones y postcondiciones de un programa.</li>

<li>Permite razonar formalmente y rigurosamente sobre la corrección
de programas.</li>

<li>Método formal más usado después del testing al ser una
herramienta de soporte durante el desarrollo de software:

<ul class="org-ul">
<li>SPARK programming language (subconjunto de Ada) y el Java
Modeling Language (JML) que usa ESC/Java y ESC/Java2.</li>

<li>Frama-C WP (weakest precondition) plugin para el lenguaje C
extendido con ACSL (ANS/ISO C Specification Language).</li>
</ul></li>
</ul>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org9b24d75" class="outline-3">
<h3 id="org9b24d75">20 / 09 / 23</h3>
<div class="outline-text-3" id="text-org9b24d75">
</div>
<div id="outline-container-org18e72d7" class="outline-4">
<h4 id="org18e72d7">Análisis Estático (Interpretación Abstracta)</h4>
<div class="outline-text-4" id="text-org18e72d7">
<p>
Las técnicas de análisis estático no requiere ejecutar el programa
o sistema; se realiza un razonamiento del modelo matemático para
analizar los estados que se generan duran la ejecución.
</p>

<ul class="org-ul">
<li>Análisis de control de flujo: información acerca de las
funciones y puntos de ejecución.</li>

<li>Análisis de flujo de datos: información de los valores o datos y
cómo cambian en el tiempo.</li>

<li>Sistemas de Efectos: representación de efectos durante la
ejecución.</li>

<li>Sistemas de Tipos: asociación de tipos a programas como
requerimientos mediante verificación de tipos estática
(compilación) o dinámica (ejecución).</li>

<li>Interpretación Abstracta: información de la ejecución del
programa usando un modelo matemático del programa que permite
analizar datos y estados del código.</li>

<li>Verificación de Modelos: Uso de modelos (fórmulas lógicas) para
establecer que se cumple la especificación.</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="org75a0b21"></a>Frama-C<br />
<div class="outline-text-5" id="text-org75a0b21">
<p>
Es un analizador estático formado por varios módulos (plugins)
para manipular árboles abstractos de sintaxis (AST) e
incorporarles anotaciones de especificaciones de C (ISO C
Specification Language).
</p>

<p>
<a href="https://www.frama-c.com/index.html">https://www.frama-c.com/index.html</a>
</p>

<p>
Nos fuciona para:
</p>

<ul class="org-ul">
<li>Entender y razonar respecto al código en C.</li>

<li>Probar formalmente propiedades de código.</li>

<li>Para reforzar convenciones de código.</li>

<li>Para prevenir fallas de seguridad.</li>
</ul>


<p>
Utiliza un lenguaje intermedio llamado CIL el cual funciona para
el análisis y transformación de programas hechos en C.
</p>

<p>
También tiene un lenguaje de especificación formal (ACSL) que usa
contratos (precondiciones, postcondiciones e invariantes).
</p>

<p>
La sintaxis que utiliza es la siguiente
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">a</span>[10];
<span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">@ loop invariant 0 &lt;= i &lt;= 10;</span>
<span style="font-weight: bold; font-style: italic;">  loop invariant \forall integer j; 0 &lt;= j &lt; i ==&gt; a[j] == j;</span>
<span style="font-weight: bold; font-style: italic;">  loop assigns i, a[0 .. i-1];</span>
<span style="font-weight: bold; font-style: italic;"> */</span>
<span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; 10; i++) <span style="font-weight: bold; text-decoration: underline;">a</span>[i] = i;
</pre>
</div>

<ul class="org-ul">
<li>Los contratos o anotaciones son condiciones de algunas partes
del código.</li>

<li>Dado el código, se agregan las anotaciones</li>

<li>El análisis de código se realiza por bloques o enunciados
(lenguaje WHILE)</li>

<li>El modelo abstracto del código es un árbol de sintaxis
abstracta.</li>
</ul>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb151b53" class="outline-3">
<h3 id="orgb151b53">22 / 09 / 23</h3>
<div class="outline-text-3" id="text-orgb151b53">
</div>
<div id="outline-container-org31782c6" class="outline-4">
<h4 id="org31782c6">Frama C</h4>
<div class="outline-text-4" id="text-org31782c6">
<ul class="org-ul">
<li>Programado en OCaml, donde el kernel es una modificación de CIL,
el lenguaje intermedio estandarizado para C.</li>

<li>El código se anota con expresiones en ACSL para expresar
contratos.</li>

<li>La representación mediante AST es la que utilizan los
analizadores.</li>

<li>Los analizadores están implementados como plugins.</li>

<li>La base de datos contiene los servicios de los plugins.</li>

<li>Los analizadores pueden operar:

<ul class="org-ul">
<li>Secuencialmente al encadenar los resultados de los análisis</li>

<li>Paralelo al combinar análisis parciales para la verificación
completa.</li>
</ul></li>
</ul>


<p>
Plgin Value Analysis utiliza un análisis de datos "hacia
adenlante" para:
</p>

<ol class="org-ol">
<li>Indicar que una instrucción purfr gallar en tiempo de
ejecución.</li>
<li>Ofrecer una sobre aproximación de los valores que pueden
almacenarse en una locación de memoria.</li>
</ol>


<ul class="org-ul">
<li>Relaciona la semántica concreta (conjunto de ejecuciones del
programa) con una abstracta.</li>

<li>La semántica abstracta es una aproximación sólida del
comportamiento que tendrá el programa en tiempo de ejecución.</li>

<li>Se realiza una ejecución simbólica del programa usando la
semántica abstracta.</li>
</ul>
</div>
</div>

<div id="outline-container-orga6562e2" class="outline-4">
<h4 id="orga6562e2">Interpretación abtracta</h4>
<div class="outline-text-4" id="text-orga6562e2">
<ul class="org-ul">
<li>Método para la verificación formal de programas al abtraer sólo
lo importante mediante la semántica abstracta.</li>

<li>Las abstracciones deben ser

<ul class="org-ul">
<li>Sólidas, ninguna conclusión derivada de la semántica abstracta
está mal respecto a ala semántica concreta y especificación
del programa.</li>

<li>Completas, ningún aspecto semántico relevante en la
especificación no ha sido abstraido.</li>
</ul></li>

<li>La interpretación abstracta ofrece un método sistemático basado
en una aproximación efectiva a la semántica concreta que puede
ser automatizado y formalmente verificado.</li>
</ul>


<p>
Hay distintas herramientas para la abstracción:
</p>

<ul class="org-ul">
<li>Dominios abstractos</li>
<li>Análisis de flujo de datos</li>
<li>Semánticas de recolección</li>
<li>Conexiones de Galois</li>
<li>Puntos fijos</li>
<li>Iteración de cómputos</li>
<li>Convergencia mediante <i>widening</i> y <i>narrowing</i></li>
<li>Solución de restricciones (Programación por restricciones)</li>
</ul>


<p>
La interpretación abstracta es:
</p>

<ul class="org-ul">
<li>Una función de abstracción \(\alpha\) "mapea" un objeto concreto o
en una aproximación representada por un objeto abstracto
\(\alpha(o)\).</li>

<li>Un dominio abstracto es un conjunto de objetos abstractos junto
con las operaciones abstractas que permiten aproximar la parte
concreta.</li>

<li>Una función de concretización \(\gamma\) "mapea" objetos
abstractos o a un objeto concreto correspondiente
\(\gamma(\hat{o})\)</li>
</ul>


<p>
<i>Semantics with Applications: &#x2026;</i>    
</p>
</div>
</div>
</div>

<div id="outline-container-org0f95c23" class="outline-3">
<h3 id="org0f95c23">27 / 09 / 23</h3>
<div class="outline-text-3" id="text-org0f95c23">
</div>
<div id="outline-container-orgb319b1d" class="outline-4">
<h4 id="orgb319b1d">Lógica Axiomática</h4>
<div class="outline-text-4" id="text-orgb319b1d">
<p>
Especifica propiedades de programas usando afirmaciones. Éstas
afirmaciones son por lo general escritas con lógica de predicados
con igualdad y "código".
</p>

<p>
Las propiedades que se definen son las conocidas como
precondiciones y postcondiciones, y se comportan como funciones
que dependen del estado del programa (memoria).
</p>

<p>
Es un sistema de deducción para razonar respecto a ternas de
Hoares y demostrar propiedades del código.
</p>
</div>
</div>
</div>

<div id="outline-container-org0452855" class="outline-3">
<h3 id="org0452855">09 / 10 / 23</h3>
<div class="outline-text-3" id="text-org0452855">
</div>
<div id="outline-container-org9c92d21" class="outline-4">
<h4 id="org9c92d21">Frama C</h4>
<div class="outline-text-4" id="text-org9c92d21">
<p>
Incorpora diferentes métodos formales para análisis estático:
</p>

<ul class="org-ul">
<li>Interpretación abstracta</li>

<li>Verificación deductiva</li>

<li>Testing con ejecución simbólica</li>

<li>Especificación simbólica</li>
</ul>


<p>
Todos los analizadores trabajan unificados al usar la
representación mediante AST y el lenguaje ACSL para expresar
contratos.
</p>

<ul class="org-ul">
<li>Los contratos son especificaciones del comportamiento de partes
del código, es una parte opaca en el código pero activa cuando
se usan para verificar condiciones de corrección del código en
cuestión.</li>

<li>Los contratos se incluyen antes de las partes que se desean
demostrar correctas y pueden ser constituidas por múltiples
anotaciones para segurar todos lo casos posibles.</li>

<li>Los contratos de funciones se usan principalmente para definir
los requerimientos (<b>requires</b>) y las garantías (<b>ensures</b>) de las
mismas.</li>

<li>Se puede incluir información de memoria (apuntadores e índices
válidos), notación lógica (conectivos), tipos, etc., para
describir condiciones de los datos</li>

<li><p>
Para los ciclos se tienen anotaciones
</p>

<p>
<code>loop invariant</code>, <code>loop assigns</code>, <code>loop variant</code>
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org92d32ca" class="outline-3">
<h3 id="org92d32ca">11 / 10 / 23</h3>
<div class="outline-text-3" id="text-org92d32ca">
</div>
<div id="outline-container-org52c2f16" class="outline-4">
<h4 id="org52c2f16">Arreglos</h4>
<div class="outline-text-4" id="text-org52c2f16">
<p>
Son la estructura de datos "tradicional" para la programación
imperativa, con los que podemos:
</p>

<ul class="org-ul">
<li>manejar elementos similares</li>

<li>acceder a elementos usando índices</li>

<li>mantener su tamaño estático</li>

<li>realizar una variedad de operaciones</li>
</ul>
</div>



<ul class="org-ul">
<li><a id="org93f25f8"></a>Ejemplo<br />
<div class="outline-text-5" id="text-org93f25f8">
<p>
De-referenciar un arreglo es equivalente a acceder al primer
elemento del arreglo, desplazarlo desde \(i\) para encontrar el
i-ésimo elemento.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tab</span>[10] = {1};
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>;
<span style="font-weight: bold; text-decoration: underline;">int</span> *<span style="font-weight: bold; font-style: italic;">p</span> = &amp;x;

<span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">@ requires p == &amp;x</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>){
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">@ assert tab[0]=1 &amp;&amp; *p == x;</span>
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">@ assert *tab == 1;</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> *<span style="font-weight: bold; font-style: italic;">q</span> = &amp;tab[3];
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">@ assert q+1 == tab + 4;</span>
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">Esta afirmaci&#243;n garantiza que el desplazo es correcto.</span>
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org4e081ce" class="outline-3">
<h3 id="org4e081ce">20 / 10 / 23</h3>
<div class="outline-text-3" id="text-org4e081ce">
</div>
<div id="outline-container-orge7e4bbb" class="outline-4">
<h4 id="orge7e4bbb">Lógica de Hoare</h4>
<div class="outline-text-4" id="text-orge7e4bbb">
<p>
Es un sistema de inferencia para estudiar la correctud parcual (no
se requiere que termine el programa para que se cumpla una terna)
de programas mediante aserciones o afirmaciones de los mismos
resultados usando ternas:
</p>

<p>
\(\{P\}S\{Q\}\)
</p>

<p>
Si \(P\) se cumple en un estado incial y la ejecución de \(S\) termina
al comenzar en el estado inicial entonces \(Q\) se cumple en el
estado en donde \(S\) se detiene.
</p>

<p>
El lenguaje de aserciones especifica condiciones en un sentido
extensional, es decir que las condiciones son predicados que
dependen de estados y permiten expresar condicio es detalladas:
</p>

<p>
<b>State</b> \(\rightarrow\) {true,false}
</p>
</div>

<ul class="org-ul">
<li><a id="orge8bce64"></a>Weakest precondition<br />
<div class="outline-text-5" id="text-orge8bce64">
<p>
Es una técnica para demostrar propiedades en donde se generan
condicionesde verificacioón basada en una semántica de
transformación de predicados.
</p>

<p>
Para una expresión \(S\) y una postcondición \(R\), la precondición
más débil es un predicado \(Q\) tal que para cualquier condición
\(P\) sucede.
</p>

<p>
\(\{P\}S\{R\}\) si y sólo si \(P\Rightarrow Q\)
</p>
</div>
</li>


<li><a id="org5e553a5"></a>Cálculo de las precondiciones más débiles<br />
<div class="outline-text-5" id="text-org5e553a5">
<p>
Considera las especificaciones de los programas (entendidas como
psotcondiciones) y una implementación particular (código) para
buscar una precondición que satisfaga ambas:
</p>

<p>
Dada una instrucción \(S\) y una postcondición \(Q\), se debe
encontrar la precondición más débil para completar una terna.
</p>

<p>
\(wp(S,Q):=WakestPrecondition\)
</p>

<p>
\(\{wp(S,Q)\}S\{Q\}\)
</p>


<p>
\(wp(x:=a,Q):=Q[x\mapsto A_{\sigma}\llbracket a\rrbracket]\)
</p>

<p>
\(wp(S_1;S_2,Q):=wp(S_1,wp(S_2,Q))\)
</p>

<p>
\(wp(S_1;(S_2;S_3),Q):=wp((S_1;S_2);S_3,Q)\)
</p>

<p>
\(wp(\texttt{if }b\texttt{ then }S_1\texttt{ else }S_2,Q):=(\mathcal{B}\llbracket b\rrbracket \Rightarrow wp(S_1,Q))\wedge(\neg\mathcal{B}\llbracket b\rrbracket\Rightarrow wp(S_2,Q))\)
</p>
</div>
</li>

<li><a id="orgd45140a"></a>Propiedades<br />
<div class="outline-text-5" id="text-orgd45140a">
<p>
El lenguaje de aserciones especifica condiciones de forma
etensional:
</p>

<p>
\(\{P\}S\{Q\}\) denota que si \(P\) cumple en un estado incial
\(\sigma\) y la ejecución de \(S\) usando \(\sigma\) termina en un
estado \(\sigma'\) entonces \(Q\) se cumple en \(\sigma'\).
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org229fa4d" class="outline-3">
<h3 id="org229fa4d">08 / 11 / 23</h3>
<div class="outline-text-3" id="text-org229fa4d">
</div>
<div id="outline-container-org1ccdb93" class="outline-4">
<h4 id="org1ccdb93">Lógica de orden superior</h4>
<div class="outline-text-4" id="text-org1ccdb93">
<p>
En este curso hemos enfatizado en dos diferentes niveles de
verificación: Testing (ejecución simbólica del código) y Lógica de
Floyd-Hoare.
</p>

<p>
La lógica de orden superior es un siguiente nivel, el cual nos
puede ayudar a demostrar la corrección total de código.
</p>

<p>
En este nivel de verificación se ve la lógica y otros estilos de
demostración para describir propiedades más generales del código y
con ello verificar que en todas las posibles ejecuciones de un
código, éste se comporta bien respecto a la especificación dada.
</p>
</div>

<ul class="org-ul">
<li><a id="orgf1eaaf8"></a>COQ<br />
<div class="outline-text-5" id="text-orgf1eaaf8">
<p>
Es un asistente de pruebas interactivo, que provee un ambiente
para definir o declarar especificaciones, razonar respecto a esas
especificaciones, demostrar porpiedades esperadas, generar código
verificado.
</p>

<p>
En éste a partir de una especificación lógica de muy alto nivel
(fórmula) se puede obtener una demostración de esa especificación
(fórmula verdad) y de esa demostración se puede extraer código
funcional bien construido.
</p>

<p>
Utiliza un estilo de programación certificada.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org9531af5" class="outline-3">
<h3 id="org9531af5">13 / 11 / 23</h3>
<div class="outline-text-3" id="text-org9531af5">
</div>
<div id="outline-container-org314a2ca" class="outline-4">
<h4 id="org314a2ca">Sistemas de tipos</h4>
<div class="outline-text-4" id="text-org314a2ca">
<p>
Brindan un mecanismo de "seguridad" a los programas y forman parte
de la definición de los lenguajes de programación.
</p>

<p>
La teoría de tipos puede ser usada como una teoría unificadora
para estudiar características de los lenguajes de programación,
como sus conceptos, propiedades y métodos prácticos y aplicables.
</p>
</div>

<ul class="org-ul">
<li><a id="org71e637f"></a>Cálculo lambda<br />
<div class="outline-text-5" id="text-org71e637f">
<p>
Se considera como un lenguaje fundamental para estudiar nociones
de cómputo, el cual también funciona como un lenguaje lógico para
especificaciones.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org61b4733" class="outline-3">
<h3 id="org61b4733">15 / 11 / 23</h3>
<div class="outline-text-3" id="text-org61b4733">
</div>
<div id="outline-container-org8dae095" class="outline-4">
<h4 id="org8dae095">Sistema</h4>
<div class="outline-text-4" id="text-org8dae095">
<p>
\[\infer{\cdot\vdash\star}{}_{\texttt{Axiom}}\]
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4d8f72" class="outline-2">
<h2 id="orgc4d8f72">Bibliografía</h2>
<div class="outline-text-2" id="text-orgc4d8f72">
<ul class="org-ul">
<li>Formal Methods, an Appetizer. Springer.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Erik Rangel Limón</p>
<p class="date">Created: 2024-08-19 Mon 11:43</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
